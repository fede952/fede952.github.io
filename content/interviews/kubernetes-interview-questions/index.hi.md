---
title: "Kubernetes (K8s) इंटरव्यू तैयारी: सीनियर लेवल प्रश्न और उत्तर"
description: "सीनियर DevOps और SRE भूमिकाओं के लिए 20 उन्नत Kubernetes इंटरव्यू प्रश्न। आर्किटेक्चर, पॉड लाइफसाइकिल, नेटवर्किंग, स्टोरेज, RBAC और प्रोडक्शन ट्रबलशूटिंग को कवर करता है।"
date: 2026-02-11
tags: ["kubernetes", "interview", "devops", "cloud-native"]
keywords: ["k8s interview questions", "cka exam prep", "kubernetes architecture questions", "kubernetes interview answers", "pod lifecycle interview", "kubernetes networking questions", "kubernetes rbac", "senior sre interview", "kubernetes troubleshooting", "helm interview questions"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Kubernetes (K8s) इंटरव्यू तैयारी: सीनियर लेवल प्रश्न और उत्तर",
    "description": "आर्किटेक्चर, नेटवर्किंग, स्टोरेज, सुरक्षा और प्रोडक्शन ट्रबलशूटिंग को कवर करने वाले 20 उन्नत Kubernetes इंटरव्यू प्रश्न।",
    "proficiencyLevel": "Advanced",
    "inLanguage": "hi"
  }
---

## सिस्टम इनिशियलाइज़ेशन

Kubernetes क्लाउड का ऑपरेटिंग सिस्टम है — और DevOps, SRE, और Platform Engineering भूमिकाओं के लिए सबसे अधिक मांग वाला कौशल। सीनियर-लेवल इंटरव्यू गहराई में जाते हैं: आपसे कंट्रोल प्लेन के आंतरिक भागों, नेटवर्किंग मॉडल, RBAC, संसाधन प्रबंधन और दबाव में प्रोडक्शन इंसिडेंट को डीबग करने के बारे में पूछा जाएगा। इस गाइड में 20 प्रश्न हैं जो शीर्ष टेक कंपनियों में इंटरव्यू में बार-बार आते हैं, Staff/Senior स्तर पर अपेक्षित गहराई प्रदर्शित करने वाले उत्तरों के साथ।

**कमांड की त्वरित समीक्षा चाहिए?** अपनी तैयारी के दौरान हमारा [Kubernetes Kubectl Cheat Sheet](/cheatsheets/kubernetes-kubectl-cheat-sheet/) खुला रखें।

---

## आर्किटेक्चर

<details>
<summary><strong>1. Kubernetes कंट्रोल प्लेन के घटकों और उनकी जिम्मेदारियों का वर्णन करें।</strong></summary>
<br>

कंट्रोल प्लेन क्लस्टर की स्थिति का प्रबंधन करता है:

- **kube-apiserver**: क्लस्टर का मुख्य द्वार। हर `kubectl` कमांड, कंट्रोलर एक्शन, और शेड्यूलर निर्णय API सर्वर से होकर गुजरता है। यह स्थिति को मान्य करता है और etcd में संरक्षित करता है।
- **etcd**: एक वितरित की-वैल्यू स्टोर जो पूरे क्लस्टर की स्थिति (वांछित स्थिति, वास्तविक स्थिति, कॉन्फ़िगरेशन, सीक्रेट) रखता है। यह सत्य का एकमात्र स्रोत है।
- **kube-scheduler**: बिना असाइन किए गए नोड वाले नए बनाए गए पॉड्स की निगरानी करता है और संसाधन आवश्यकताओं, एफ़िनिटी नियमों, टेंट्स और बाधाओं के आधार पर नोड का चयन करता है।
- **kube-controller-manager**: कंट्रोलर लूप (Deployment, ReplicaSet, Node, Job कंट्रोलर) चलाता है जो लगातार वांछित स्थिति को वास्तविक स्थिति के साथ मिलान करते हैं।
- **cloud-controller-manager**: LoadBalancer, स्टोरेज प्रोविज़निंग और नोड लाइफसाइकिल के लिए क्लाउड प्रोवाइडर API के साथ एकीकृत होता है।
</details>

<details>
<summary><strong>2. जब आप `kubectl apply -f deployment.yaml` चलाते हैं तो क्या होता है?</strong></summary>
<br>

1. `kubectl` Deployment मैनिफ़ेस्ट के साथ **API सर्वर** को HTTP POST/PATCH भेजता है।
2. API सर्वर अनुरोध को **मान्य** करता है (प्रमाणीकरण, RBAC के माध्यम से प्राधिकरण, एडमिशन कंट्रोलर)।
3. API सर्वर Deployment ऑब्जेक्ट को **etcd** में लिखता है।
4. **Deployment कंट्रोलर** नए Deployment का पता लगाता है और एक **ReplicaSet** बनाता है।
5. **ReplicaSet कंट्रोलर** इसका पता लगाता है और निर्दिष्ट संख्या में **Pod** ऑब्जेक्ट बनाता है।
6. **शेड्यूलर** अनशेड्यूल्ड पॉड्स का पता लगाता है और संसाधन उपलब्धता और बाधाओं के आधार पर प्रत्येक को एक नोड पर असाइन करता है।
7. प्रत्येक असाइन किए गए नोड पर **kubelet** पॉड असाइनमेंट का पता लगाता है, कंटेनर इमेज पुल करता है, और कंटेनर रनटाइम (containerd/CRI-O) के माध्यम से कंटेनर शुरू करता है।
8. प्रत्येक नोड पर **kube-proxy** अगर कोई Service जुड़ा है तो iptables/IPVS नियमों को अपडेट करता है।
</details>

<details>
<summary><strong>3. Deployment, StatefulSet और DaemonSet में क्या अंतर है?</strong></summary>
<br>

- **Deployment**: स्टेटलेस एप्लिकेशन का प्रबंधन करता है। पॉड्स विनिमेय हैं, स्वतंत्र रूप से स्केल किए जा सकते हैं, और किसी भी क्रम में बनाए/नष्ट किए जाते हैं। वेब सर्वर, API, वर्कर्स के लिए सबसे अच्छा।
- **StatefulSet**: स्टेटफुल एप्लिकेशन का प्रबंधन करता है। प्रत्येक पॉड को एक **स्थिर होस्टनेम** (`pod-0`, `pod-1`), **स्थायी स्टोरेज** (प्रति पॉड PVC) मिलता है, और पॉड्स **क्रम** में बनाए/नष्ट किए जाते हैं। डेटाबेस, Kafka, ZooKeeper के लिए सबसे अच्छा।
- **DaemonSet**: **प्रति नोड एक पॉड** सुनिश्चित करता है। जब एक नया नोड क्लस्टर में शामिल होता है, एक पॉड स्वचालित रूप से उस पर शेड्यूल हो जाता है। लॉग कलेक्टर, मॉनिटरिंग एजेंट, नेटवर्क प्लगइन के लिए सबसे अच्छा।
</details>

<details>
<summary><strong>4. पॉड लाइफसाइकिल और उसके चरणों को समझाएं।</strong></summary>
<br>

एक पॉड इन चरणों से गुजरता है:

1. **Pending**: पॉड स्वीकार किया गया है लेकिन अभी तक शेड्यूल नहीं हुआ या इमेज पुल हो रही हैं।
2. **Running**: कम से कम एक कंटेनर चल रहा है या शुरू/पुनः आरंभ हो रहा है।
3. **Succeeded**: सभी कंटेनर कोड 0 के साथ बाहर निकले (Jobs/बैच वर्कलोड के लिए)।
4. **Failed**: सभी कंटेनर समाप्त हो गए, कम से कम एक गैर-शून्य कोड के साथ बाहर निकला।
5. **Unknown**: नोड अनुपलब्ध है, पॉड की स्थिति निर्धारित नहीं की जा सकती।

चलते हुए पॉड के भीतर, कंटेनर इन स्थितियों में हो सकते हैं: **Waiting** (इमेज पुल, init कंटेनर), **Running**, या **Terminated** (बाहर निकला या क्रैश हुआ)।
</details>

## नेटवर्किंग

<details>
<summary><strong>5. Kubernetes नेटवर्किंग मॉडल को समझाएं।</strong></summary>
<br>

Kubernetes नेटवर्किंग तीन मूलभूत नियमों का पालन करती है:

1. **प्रत्येक पॉड को अपना IP एड्रेस मिलता है** — पॉड्स के बीच कोई NAT नहीं।
2. **सभी पॉड्स सभी अन्य पॉड्स के साथ** नोड्स के पार बिना NAT के संवाद कर सकते हैं।
3. **पॉड जो IP अपने लिए देखता है** वही IP है जो दूसरे उस तक पहुंचने के लिए उपयोग करते हैं।

यह CNI (Container Network Interface) प्लगइन जैसे Calico, Flannel, Cilium, या Weave द्वारा लागू किया जाता है। वे एक ओवरले या अंडरले नेटवर्क बनाते हैं जो इन नियमों को पूरा करता है। प्रत्येक नोड को एक पॉड CIDR सबनेट मिलता है, और CNI प्लगइन नोड्स के बीच रूटिंग संभालता है।
</details>

<details>
<summary><strong>6. ClusterIP, NodePort और LoadBalancer सेवाओं में क्या अंतर है?</strong></summary>
<br>

- **ClusterIP** (डिफ़ॉल्ट): केवल आंतरिक वर्चुअल IP। केवल क्लस्टर के भीतर से पहुंच योग्य। अंतर-सेवा संचार के लिए उपयोग।
- **NodePort**: प्रत्येक नोड के IP पर एक स्थिर पोर्ट (30000-32767) पर सेवा को उजागर करता है। बाहरी ट्रैफ़िक `<NodeIP>:<NodePort>` तक पहुंच सकता है। ClusterIP के ऊपर बनता है।
- **LoadBalancer**: क्लाउड प्रोवाइडर के माध्यम से बाहरी लोड बैलेंसर प्रोविज़न करता है। सार्वजनिक IP/DNS प्राप्त करता है। NodePort के ऊपर बनता है। प्रोडक्शन सार्वजनिक सेवाओं के लिए उपयोग।

**ExternalName** भी है, जो एक सेवा को DNS CNAME से मैप करता है (कोई प्रॉक्सीइंग नहीं, केवल DNS रिज़ॉल्यूशन)।
</details>

<details>
<summary><strong>7. Ingress क्या है और यह Service से कैसे भिन्न है?</strong></summary>
<br>

एक **Service** लेयर 4 (TCP/UDP) पर काम करता है — IP और पोर्ट के आधार पर पॉड्स को ट्रैफ़िक रूट करता है।

एक **Ingress** लेयर 7 (HTTP/HTTPS) पर काम करता है — होस्टनेम और URL पथ के आधार पर ट्रैफ़िक रूट करता है। एक एकल Ingress `api.example.com` को API सेवा और `app.example.com` को फ्रंटएंड सेवा पर, सब एक लोड बैलेंसर के माध्यम से रूट कर सकता है।

Ingress को रूटिंग नियमों को वास्तव में लागू करने के लिए एक **Ingress Controller** (nginx-ingress, Traefik, HAProxy, AWS ALB) की आवश्यकता होती है। Ingress संसाधन केवल एक कॉन्फ़िगरेशन है — कंट्रोलर काम करता है।
</details>

<details>
<summary><strong>8. Kubernetes क्लस्टर के अंदर DNS कैसे काम करता है?</strong></summary>
<br>

Kubernetes क्लस्टर ऐड-ऑन के रूप में **CoreDNS** (या kube-dns) चलाता है। प्रत्येक सेवा को एक DNS रिकॉर्ड मिलता है:

- `<service-name>.<namespace>.svc.cluster.local` → ClusterIP
- `<pod-ip-dashed>.<namespace>.pod.cluster.local` → Pod IP

जब एक पॉड `my-service` के लिए DNS क्वेरी करता है, `/etc/resolv.conf` में रिज़ॉल्वर (kubelet द्वारा कॉन्फ़िगर) सर्च डोमेन जोड़ता है और CoreDNS से क्वेरी करता है। CoreDNS Service/Endpoint परिवर्तनों के लिए API सर्वर की निगरानी करता है और अपने रिकॉर्ड स्वचालित रूप से अपडेट करता है।
</details>

## स्टोरेज

<details>
<summary><strong>9. PersistentVolume (PV), PersistentVolumeClaim (PVC), और StorageClass को समझाएं।</strong></summary>
<br>

- **PersistentVolume (PV)**: एक एडमिन द्वारा या StorageClass द्वारा गतिशील रूप से प्रोविज़न किया गया स्टोरेज का एक भाग। किसी भी पॉड से स्वतंत्र रूप से मौजूद है। पॉड्स से अलग लाइफसाइकिल है।
- **PersistentVolumeClaim (PVC)**: पॉड द्वारा स्टोरेज का अनुरोध। आकार, एक्सेस मोड और वैकल्पिक रूप से StorageClass निर्दिष्ट करता है। Kubernetes PVC को मिलान करने वाले PV से बाइंड करता है।
- **StorageClass**: स्टोरेज का एक वर्ग (SSD, HDD, NFS) और गतिशील रूप से PV बनाने वाले प्रोविज़नर को परिभाषित करता है। ऑन-डिमांड स्टोरेज प्रोविज़निंग सक्षम करता है — किसी एडमिन हस्तक्षेप की आवश्यकता नहीं।

प्रवाह: Pod PVC को संदर्भित करता है → PVC StorageClass से स्टोरेज अनुरोध करता है → StorageClass प्रोविज़नर को ट्रिगर करता है → प्रोविज़नर PV बनाता है → PVC PV से बाइंड होता है → Pod PV को माउंट करता है।
</details>

<details>
<summary><strong>10. एक्सेस मोड और रिक्लेम पॉलिसी क्या हैं?</strong></summary>
<br>

**एक्सेस मोड**:
- **ReadWriteOnce (RWO)**: एकल नोड द्वारा रीड/राइट माउंट। सबसे सामान्य (AWS EBS, GCE PD)।
- **ReadOnlyMany (ROX)**: कई नोड्स द्वारा केवल-पठन माउंट। साझा कॉन्फ़िग के लिए उपयोग।
- **ReadWriteMany (RWX)**: कई नोड्स द्वारा रीड/राइट माउंट। नेटवर्क स्टोरेज आवश्यक (NFS, EFS, CephFS)।

**रिक्लेम पॉलिसी** (PVC हटाए जाने पर क्या होता है):
- **Retain**: PV अपने डेटा के साथ रखा जाता है। एडमिन को मैन्युअल रूप से रिक्लेम करना होगा।
- **Delete**: PV और अंतर्निहित स्टोरेज हटा दिया जाता है। डायनामिक प्रोविज़निंग का डिफ़ॉल्ट।
- **Recycle** (पदावनत): वॉल्यूम पर बेसिक `rm -rf`। इसके बजाय Retain या Delete का उपयोग करें।
</details>

## सुरक्षा और RBAC

<details>
<summary><strong>11. Kubernetes में RBAC कैसे काम करता है?</strong></summary>
<br>

RBAC (रोल-बेस्ड एक्सेस कंट्रोल) के चार ऑब्जेक्ट हैं:

- **Role**: **एकल नेमस्पेस** के भीतर संसाधनों (pods, services, secrets) पर अनुमतियां (क्रियाएं: get, list, create, delete) परिभाषित करता है।
- **ClusterRole**: Role के समान लेकिन **क्लस्टर-वाइड** (सभी नेमस्पेस, या क्लस्टर-स्कोप्ड संसाधन जैसे नोड्स)।
- **RoleBinding**: एक नेमस्पेस के भीतर Role को उपयोगकर्ता, समूह, या सर्विस अकाउंट से बाइंड करता है।
- **ClusterRoleBinding**: पूरे क्लस्टर में ClusterRole को विषय से बाइंड करता है।

सिद्धांत: आवश्यक न्यूनतम अनुमतियों से शुरू करें। एप्लिकेशन सर्विस अकाउंट्स को कभी `cluster-admin` से बाइंड न करें। `kubectl auth can-i` के साथ नियमित रूप से RBAC का ऑडिट करें।
</details>

<details>
<summary><strong>12. Pod Security Standards (PSS) क्या हैं?</strong></summary>
<br>

Pod Security Standards ने PodSecurityPolicies (K8s 1.25 में हटाई गई) को बदल दिया। वे तीन सुरक्षा स्तर परिभाषित करते हैं:

- **Privileged**: अप्रतिबंधित। सब कुछ अनुमति। सिस्टम-लेवल पॉड्स (CNI प्लगइन, स्टोरेज ड्राइवर) के लिए उपयोग।
- **Baseline**: ज्ञात प्रिविलेज एस्केलेशन को रोकता है। hostNetwork, hostPID, प्रिविलेज्ड कंटेनर ब्लॉक करता है, लेकिन अधिकांश वर्कलोड की अनुमति देता है।
- **Restricted**: अधिकतम सुरक्षा। non-root, सभी capabilities छोड़ना, केवल-पठन रूट फ़ाइलसिस्टम, कोई प्रिविलेज एस्केलेशन नहीं की आवश्यकता।

लेबल का उपयोग करके नेमस्पेस स्तर पर **Pod Security Admission** कंट्रोलर के माध्यम से लागू:
```yaml
metadata:
  labels:
    pod-security.kubernetes.io/enforce: restricted
```
</details>

<details>
<summary><strong>13. Kubernetes में सीक्रेट्स को सुरक्षित रूप से कैसे प्रबंधित करें?</strong></summary>
<br>

डिफ़ॉल्ट Kubernetes सीक्रेट्स **base64 एन्कोडेड हैं, एन्क्रिप्टेड नहीं**। API एक्सेस वाला कोई भी व्यक्ति उन्हें डिकोड कर सकता है।

हार्डनिंग कदम:
1. etcd में **रेस्ट पर एन्क्रिप्शन सक्षम करें** (AES-CBC या KMS प्रोवाइडर के साथ `EncryptionConfiguration`)।
2. External Secrets Operator या CSI Secrets Store Driver के साथ **बाहरी सीक्रेट मैनेजर का उपयोग करें** (Vault, AWS Secrets Manager)।
3. **RBAC**: सीक्रेट्स पर `get`/`list` केवल उन सर्विस अकाउंट्स तक सीमित करें जिन्हें उनकी आवश्यकता है।
4. **फ़ाइलों के रूप में माउंट करें**, एनवायरनमेंट वेरिएबल के रूप में नहीं — एनवायरनमेंट वेरिएबल लॉग, क्रैश डंप और `/proc` के माध्यम से लीक हो सकते हैं।
5. **सीक्रेट्स को नियमित रूप से रोटेट करें** और जहां संभव हो अल्पकालिक क्रेडेंशियल का उपयोग करें।
</details>

## शेड्यूलिंग और संसाधन

<details>
<summary><strong>14. संसाधन रिक्वेस्ट और लिमिट समझाएं।</strong></summary>
<br>

- **रिक्वेस्ट (Requests)**: कंटेनर को **गारंटीकृत** CPU/मेमोरी की मात्रा। शेड्यूलर रिक्वेस्ट का उपयोग यह तय करने के लिए करता है कि किस नोड पर पर्याप्त क्षमता है।
- **लिमिट (Limits)**: कंटेनर द्वारा उपयोग की जा सकने वाली **अधिकतम** मात्रा। यदि कंटेनर मेमोरी लिमिट से अधिक हो जाता है, तो OOM-किल्ड हो जाता है। CPU लिमिट से अधिक होने पर, थ्रॉटल किया जाता है।

रिक्वेस्ट/लिमिट पर आधारित QoS क्लास:
- **Guaranteed**: सभी कंटेनरों के लिए रिक्वेस्ट == लिमिट। सर्वोच्च प्राथमिकता, अंतिम में इविक्ट होता है।
- **Burstable**: रिक्वेस्ट < लिमिट। मध्यम प्राथमिकता।
- **BestEffort**: कोई रिक्वेस्ट या लिमिट सेट नहीं। दबाव में सबसे पहले इविक्ट होता है।

सर्वोत्तम अभ्यास: हमेशा रिक्वेस्ट (शेड्यूलिंग सटीकता के लिए) और लिमिट (क्लस्टर स्थिरता के लिए) सेट करें।
</details>

<details>
<summary><strong>15. टेंट्स, टॉलरेशंस और नोड एफ़िनिटी क्या हैं?</strong></summary>
<br>

- **टेंट्स (Taints)** नोड्स पर लागू होते हैं: "जब तक पॉड्स इस टेंट को सहन नहीं करते, यहां शेड्यूल न करें।" उदाहरण: `kubectl taint nodes gpu-node gpu=true:NoSchedule`।
- **टॉलरेशंस (Tolerations)** पॉड्स पर लागू होते हैं: "मैं इस टेंट को सहन कर सकता हूं।" मिलान करने वाले टॉलरेशंस वाले पॉड्स टेंटेड नोड्स पर शेड्यूल किए जा सकते हैं।
- **नोड एफ़िनिटी (Node Affinity)** एक पॉड स्पेक है जो कहता है "विशिष्ट लेबल वाले नोड्स पर शेड्यूलिंग को प्राथमिकता दें या आवश्यक करें।" उदाहरण: `disktype=ssd` वाले नोड्स की आवश्यकता।

एक साथ उपयोग करें: GPU नोड्स पर टेंट लगाएं → केवल GPU टॉलरेशंस और GPU एफ़िनिटी वाले पॉड्स वहां पहुंचेंगे। गैर-GPU वर्कलोड को महंगे हार्डवेयर बर्बाद करने से रोकता है।
</details>

## ट्रबलशूटिंग

<details>
<summary><strong>16. एक पॉड CrashLoopBackOff में फंसा हुआ है। आप इसे कैसे डीबग करते हैं?</strong></summary>
<br>

`CrashLoopBackOff` का मतलब है कि कंटेनर बार-बार क्रैश हो रहा है और Kubernetes रीस्टार्ट करने से पहले प्रतीक्षा कर रहा है (5 मिनट तक एक्सपोनेंशियल बैकऑफ)।

डीबग कदम:
1. `kubectl describe pod <name>` — Events, Last State, Exit Code जांचें।
2. `kubectl logs <pod> --previous` — क्रैश हुए इंस्टेंस के लॉग पढ़ें।
3. एग्ज़िट कोड विश्लेषण: 1 = ऐप एरर, 137 = OOM किल्ड, 139 = सेगफॉल्ट, 143 = SIGTERM।
4. यदि कंटेनर लॉग के लिए बहुत तेजी से क्रैश होता है: `kubectl run debug --image=<image> --command -- sleep 3600` और एनवायरनमेंट की जांच के लिए exec करें।
5. जांचें कि readiness/liveness प्रोब गलत तरीके से कॉन्फ़िगर तो नहीं (प्रोब गलत पोर्ट/पथ पर)।
6. संसाधन लिमिट जांचें — कंटेनर कुछ भी लॉग करने से पहले OOM किल्ड हो सकता है।
</details>

<details>
<summary><strong>17. एक Service पॉड्स को ट्रैफ़िक रूट नहीं कर रहा। आप क्या जांचते हैं?</strong></summary>
<br>

1. **लेबल मिलान**: Service का `spec.selector` पॉड के `metadata.labels` से बिल्कुल मेल खाना चाहिए।
2. **Endpoints मौजूद हैं**: `kubectl get endpoints <service>` — यदि खाली है, तो सेलेक्टर किसी चल रहे पॉड से मेल नहीं खाता।
3. **पॉड्स Ready हैं**: केवल readiness प्रोब पास करने वाले पॉड्स Endpoints में दिखते हैं। Ready स्थिति के लिए `kubectl get pods` जांचें।
4. **पोर्ट बेमेल**: Service का `targetPort` उस पोर्ट से मेल खाना चाहिए जिस पर कंटेनर वास्तव में सुन रहा है।
5. **Network Policy**: एक NetworkPolicy पॉड्स में इनग्रेस को ब्लॉक कर सकती है।
6. **DNS**: डीबग पॉड से, DNS रिज़ॉल्यूशन काम कर रहा है यह सत्यापित करने के लिए `nslookup <service-name>`।
</details>

<details>
<summary><strong>18. ज़ीरो-डाउनटाइम डिप्लॉयमेंट कैसे करते हैं?</strong></summary>
<br>

1. **रोलिंग अपडेट रणनीति** (डिफ़ॉल्ट): `maxUnavailable: 0` और `maxSurge: 1` सेट करें ताकि पुराने पॉड्स केवल नए पॉड्स के Ready होने के बाद ही हटाए जाएं।
2. **Readiness प्रोब**: बिना readiness प्रोब के, Kubernetes शुरू होने के तुरंत बाद पॉड को Ready मानता है — ऐप के इनिशियलाइज़ होने से पहले ट्रैफ़िक उस तक पहुंचता है।
3. **PreStop हुक**: एक छोटे sleep (5-10 सेकंड) के साथ `preStop` लाइफसाइकिल हुक जोड़ें ताकि पॉड को Service एंडपॉइंट से हटाए जाने से पहले इन-फ़्लाइट रिक्वेस्ट पूरे हो सकें।
4. **PodDisruptionBudget (PDB)**: स्वैच्छिक व्यवधानों (नोड ड्रेन, अपग्रेड) के दौरान पॉड्स की न्यूनतम संख्या हमेशा उपलब्ध रहना सुनिश्चित करता है।
5. **ग्रेसफुल शटडाउन**: एप्लिकेशन को SIGTERM हैंडल करना चाहिए और बाहर निकलने से पहले सक्रिय रिक्वेस्ट पूरे करने चाहिए।
</details>

<details>
<summary><strong>19. Horizontal Pod Autoscaler क्या है और यह कैसे काम करता है?</strong></summary>
<br>

HPA देखे गए मेट्रिक्स (CPU, मेमोरी, या कस्टम मेट्रिक्स) के आधार पर पॉड रेप्लिकाओं की संख्या को स्वचालित रूप से स्केल करता है।

यह कैसे काम करता है:
1. HPA हर 15 सेकंड में **Metrics Server** (या कस्टम मेट्रिक्स API) से क्वेरी करता है।
2. गणना करता है: `desiredReplicas = ceil(currentReplicas × (currentMetric / targetMetric))`।
3. यदि वांछित रेप्लिका वर्तमान से भिन्न हैं, तो Deployment के रेप्लिका काउंट को अपडेट करता है।
4. कूलडाउन अवधि थ्रैशिंग को रोकती है: स्केल-अप स्थिरीकरण (डिफ़ॉल्ट 0 सेकंड), स्केल-डाउन स्थिरीकरण (डिफ़ॉल्ट 300 सेकंड)।

आवश्यकताएं: Metrics Server इंस्टॉल, कंटेनरों पर संसाधन रिक्वेस्ट परिभाषित (CPU/मेमोरी मेट्रिक्स के लिए), न्यूनतम/अधिकतम रेप्लिका सीमाएं कॉन्फ़िगर।
</details>

<details>
<summary><strong>20. liveness प्रोब और readiness प्रोब में क्या अंतर है?</strong></summary>
<br>

- **Liveness प्रोब**: "क्या कंटेनर जीवित है?" यदि विफल होता है, kubelet कंटेनर को **किल और रीस्टार्ट** करता है। डेडलॉक या फ्रोज़न प्रक्रियाओं का पता लगाने के लिए उपयोग।
- **Readiness प्रोब**: "क्या कंटेनर ट्रैफ़िक सर्व करने के लिए तैयार है?" यदि विफल होता है, पॉड को **Service एंडपॉइंट से हटा दिया जाता है** (कोई ट्रैफ़िक रूट नहीं), लेकिन कंटेनर रीस्टार्ट नहीं होता। वार्म-अप अवधि, डिपेंडेंसी चेक, अस्थायी ओवरलोड के लिए उपयोग।

एक **Startup प्रोब** भी है: ऐप शुरू होने तक liveness/readiness प्रोब को अक्षम करता है। समय से पहले किल को रोकने के लिए धीमी-शुरू होने वाले एप्लिकेशन के लिए उपयोगी।

सामान्य गलती: एक liveness प्रोब का उपयोग करना जो डाउनस्ट्रीम डिपेंडेंसी (डेटाबेस) की जांच करता है। यदि डेटाबेस डाउन हो जाता है, सभी पॉड्स रीस्टार्ट होते हैं — आउटेज को और बुरा बनाते हैं। Liveness को केवल एप्लिकेशन स्वयं की जांच करनी चाहिए।
</details>
