---
title: "Собеседование Linux SysAdmin: Процессы, Права доступа и Сети"
description: "20 основных вопросов для собеседования по системному администрированию Linux для ролей Senior SysAdmin и DevOps. Охватывает права доступа к файлам, управление процессами, systemd, сети и устранение неполадок."
date: 2026-02-11
tags: ["linux", "interview", "sysadmin", "devops"]
keywords: ["linux interview questions", "red hat interview", "bash scripting questions", "linux permissions interview", "sysadmin interview questions", "linux process management", "systemd interview", "linux networking questions", "senior linux engineer", "rhcsa exam prep"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Собеседование Linux SysAdmin: Процессы, Права доступа и Сети",
    "description": "20 основных вопросов для собеседования по системному администрированию Linux о правах доступа, процессах, systemd и сетях.",
    "proficiencyLevel": "Advanced",
    "inLanguage": "ru"
  }
---

## Инициализация системы

Системное администрирование Linux — это основа современной инфраструктуры. Независимо от того, проходите ли вы собеседование на роль SysAdmin, DevOps, SRE или Cloud Engineer, вас будут проверять на способность управлять пользователями, устранять проблемы процессов, настраивать сети и защищать серверы — всё из командной строки. Это руководство охватывает 20 вопросов, которые отделяют старших кандидатов от младших, с ответами, демонстрирующими реальный операционный опыт.

**Нужна быстрая справка по командам?** Держите наш [Шпаргалку Linux SysAdmin](/cheatsheets/linux-sysadmin-permissions/) открытой во время подготовки.

---

## Права доступа и владение файлами

<details>
<summary><strong>1. Объясните модель прав доступа Linux (rwx, восьмеричная нотация, специальные биты).</strong></summary>
<br>

Каждый файл имеет три уровня прав: **Владелец**, **Группа**, **Остальные**. Каждый уровень может иметь **Чтение (r=4)**, **Запись (w=2)**, **Выполнение (x=1)**.

Восьмеричная нотация объединяет их: `chmod 755` = rwxr-xr-x (владелец: полные права, группа/остальные: чтение+выполнение).

**Специальные биты**:
- **SUID (4000)**: Файл выполняется от имени владельца файла, а не пользователя, который его запускает. Пример: `/usr/bin/passwd` запускается от имени root, чтобы пользователи могли менять свой пароль.
- **SGID (2000)**: Для файлов — выполняется от имени группы-владельца. Для каталогов — новые файлы наследуют группу каталога.
- **Sticky bit (1000)**: Для каталогов — только владелец файла может удалять свои файлы. Классический пример: `/tmp`.
</details>

<details>
<summary><strong>2. В чём разница между жёсткими и символическими ссылками?</strong></summary>
<br>

- **Жёсткая ссылка**: Прямая ссылка на inode (фактические данные на диске). Несколько жёстких ссылок на один файл имеют одинаковый номер inode. Удаление одной жёсткой ссылки не влияет на другие — данные сохраняются до удаления всех жёстких ссылок. Не может пересекать границы файловой системы. Не может ссылаться на каталоги.
- **Символическая ссылка (symlink)**: Указатель на путь к файлу (как ярлык). Имеет собственный inode. Если целевой файл удалён, символическая ссылка становится висячей. Может пересекать файловые системы. Может ссылаться на каталоги.

Используйте `ls -li` для просмотра номеров inode и подтверждения связей между жёсткими ссылками.
</details>

<details>
<summary><strong>3. Разработчик не может писать в общий каталог. Как вы диагностируете и решаете проблему?</strong></summary>
<br>

Диагностические шаги:
1. `ls -la /shared/` — проверить владельца и права.
2. `id developer` — проверить, к каким группам принадлежит пользователь.
3. `getfacl /shared/` — проверить ACL, которые могут переопределять стандартные права.

Типичные решения:
- Добавить пользователя в группу каталога: `sudo usermod -aG devteam developer`.
- Установить SGID на каталог, чтобы новые файлы наследовали группу: `chmod g+s /shared/`.
- Если нужны ACL: `setfacl -m u:developer:rwx /shared/`.
- Убедиться, что umask не блокирует запись для группы (проверить командой `umask`).
</details>

<details>
<summary><strong>4. Что такое umask и как он влияет на создание файлов?</strong></summary>
<br>

`umask` определяет права по умолчанию, **удаляемые** у новых файлов и каталогов. Это битовая маска, вычитаемая из максимальных прав.

- Максимум по умолчанию для файлов: 666 (без выполнения по умолчанию).
- Максимум по умолчанию для каталогов: 777.
- С `umask 022`: файлы получают 644 (rw-r--r--), каталоги получают 755 (rwxr-xr-x).
- С `umask 077`: файлы получают 600 (rw-------), каталоги получают 700 (rwx------).

Устанавливается на уровне системы в `/etc/profile` или для пользователя в `~/.bashrc`. Критически важно для безопасности — слишком мягкий umask может раскрыть конфиденциальные файлы неавторизованным пользователям.
</details>

## Управление процессами

<details>
<summary><strong>5. Объясните разницу между процессом, потоком и демоном.</strong></summary>
<br>

- **Процесс**: Экземпляр запущенной программы со своим собственным пространством памяти, PID, файловыми дескрипторами и окружением. Создаётся через `fork()` или `exec()`.
- **Поток**: Легковесная единица выполнения внутри процесса. Потоки разделяют одно пространство памяти и файловые дескрипторы, но имеют собственный стек и регистры. Создаются быстрее, чем процессы.
- **Демон**: Фоновый процесс, работающий без управляющего терминала. Обычно запускается при загрузке, работает непрерывно и предоставляет сервис (sshd, nginx, cron). Условно именуется с суффиксом `d`.
</details>

<details>
<summary><strong>6. Что такое зомби-процессы и как с ними справляться?</strong></summary>
<br>

**Зомби** — это процесс, который завершил выполнение, но всё ещё имеет запись в таблице процессов, потому что его родитель не вызвал `wait()` для чтения кода завершения. Он не потребляет ресурсов, кроме слота PID.

Идентификация зомби: `ps aux | grep Z` — они показывают статус `Z` (defunct).

Вы **не можете** убить зомби — он уже мёртв. Чтобы его удалить:
1. Отправьте `SIGCHLD` родительскому процессу: `kill -s SIGCHLD <parent_pid>`.
2. Если родитель игнорирует сигнал, уничтожение родительского процесса сделает зомби сиротой, который будет усыновлён `init` (PID 1). Init автоматически вызывает `wait()` и очищает его.

Большое количество зомби обычно указывает на дефектный родительский процесс, который не собирает своих потомков.
</details>

<details>
<summary><strong>7. Объясните сигналы Linux. Что такое SIGTERM, SIGKILL и SIGHUP?</strong></summary>
<br>

Сигналы — это программные прерывания, отправляемые процессам:

- **SIGTERM (15)**: Вежливый запрос на завершение. Процесс может перехватить его, очистить ресурсы и корректно завершиться. Это то, что `kill <pid>` отправляет по умолчанию.
- **SIGKILL (9)**: Принудительное завершение. Не может быть перехвачен, заблокирован или проигнорирован. Ядро немедленно завершает процесс. Используйте только в крайнем случае — никакая очистка невозможна.
- **SIGHUP (1)**: Исторически "отбой". Многие демоны (nginx, Apache) перезагружают свою конфигурацию при получении SIGHUP вместо перезапуска.
- **SIGINT (2)**: Прерывание, отправляется по Ctrl+C.
- **SIGSTOP/SIGCONT (19/18)**: Приостановить и возобновить процесс.
</details>

<details>
<summary><strong>8. Как найти и завершить процесс, потребляющий слишком много CPU?</strong></summary>
<br>

1. Идентифицировать процесс: `top -o %CPU` или `ps aux --sort=-%cpu | head -10`.
2. Получить детали: `ls -l /proc/<pid>/exe` чтобы увидеть фактический бинарный файл.
3. Проверить, что он делает: `strace -p <pid>` для системных вызовов, `lsof -p <pid>` для открытых файлов.
4. Корректная остановка: `kill <pid>` (SIGTERM) — позволить очистку.
5. Принудительная остановка: `kill -9 <pid>` (SIGKILL) — только если SIGTERM не помогает.
6. Предотвращение повторения: Если управляется systemd, установить `CPUQuota=50%` в unit-файле сервиса.
</details>

## Systemd и сервисы

<details>
<summary><strong>9. Что такое systemd и чем он отличается от SysVinit?</strong></summary>
<br>

**SysVinit**: Последовательный процесс загрузки с использованием shell-скриптов в `/etc/init.d/`. Сервисы запускаются один за другим в определённом уровне выполнения. Медленная загрузка. Простой, но ограниченное управление зависимостями.

**systemd**: Параллельный процесс загрузки с использованием unit-файлов. Поддерживает зависимости, активацию через сокеты, запуск сервисов по требованию, cgroups для контроля ресурсов и journald для логирования. Значительно более быстрая загрузка. Управляет сервисами, таймерами, монтированиями, сокетами и целями.

systemd является системой инициализации по умолчанию в RHEL, Ubuntu, Debian, Fedora, SUSE и Arch.
</details>

<details>
<summary><strong>10. Как создать пользовательский сервис systemd?</strong></summary>
<br>

Создайте unit-файл в `/etc/systemd/system/myapp.service`:

```ini
[Unit]
Description=My Application
After=network.target

[Service]
Type=simple
User=deploy
WorkingDirectory=/opt/myapp
ExecStart=/opt/myapp/bin/server
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

Затем: `sudo systemctl daemon-reload && sudo systemctl enable --now myapp`.

Ключевые значения `Type`: `simple` (по умолчанию, основной процесс работает на переднем плане), `forking` (процесс форкается в фон, нужен `PIDFile`), `oneshot` (выполняется один раз и завершается), `notify` (процесс сигнализирует о готовности через sd_notify).
</details>

<details>
<summary><strong>11. Как анализировать производительность загрузки с помощью systemd?</strong></summary>
<br>

- `systemd-analyze` — общее время загрузки.
- `systemd-analyze blame` — список сервисов, отсортированных по времени запуска.
- `systemd-analyze critical-chain` — дерево критического пути загрузки.
- `systemd-analyze plot > boot.svg` — генерация визуальной временной шкалы последовательности загрузки.
- `journalctl -b -p err` — ошибки текущей загрузки.

Для ускорения загрузки: отключить ненужные сервисы (`systemctl disable`), переключить сервисы на активацию через сокеты (запуск по требованию) и определить медленные сервисы из вывода blame.
</details>

## Сети

<details>
<summary><strong>12. Объясните трёхстороннее рукопожатие TCP.</strong></summary>
<br>

1. **SYN**: Клиент отправляет SYN-пакет серверу с начальным номером последовательности.
2. **SYN-ACK**: Сервер отвечает SYN-ACK, подтверждая SYN клиента и отправляя свой номер последовательности.
3. **ACK**: Клиент отправляет ACK, подтверждая номер последовательности сервера. Соединение установлено.

Разрыв использует четырёхстороннее рукопожатие: FIN → ACK → FIN → ACK (каждая сторона независимо закрывает свою половину соединения).

Отладка: `ss -tuln` (прослушиваемые порты), `ss -tulnp` (с именами процессов), `tcpdump -i eth0 port 80` (захват пакетов).
</details>

<details>
<summary><strong>13. В чём разница между TCP и UDP?</strong></summary>
<br>

- **TCP** (Transmission Control Protocol): Ориентированный на соединение, надёжный, упорядоченная доставка. Использует рукопожатие, подтверждения, повторные передачи. Более высокие накладные расходы. Используется для HTTP, SSH, FTP, баз данных.
- **UDP** (User Datagram Protocol): Без соединения, ненадёжный, без гарантированного порядка. Без рукопожатия, без подтверждений. Меньшие накладные расходы, меньшая задержка. Используется для DNS, DHCP, VoIP, потокового вещания, игр.

Ключевое понимание: "Ненадёжный" не значит плохой — это значит, что приложение само обрабатывает надёжность при необходимости. DNS использует UDP, потому что запросы маленькие и быстрые; если ответ потерян, клиент просто отправляет запрос заново.
</details>

<details>
<summary><strong>14. Сервер не может достичь внешнего IP. Как вы устраняете неполадки?</strong></summary>
<br>

Послойный подход:
1. **L1 - Физический**: `ip link show` — интерфейс активен?
2. **L2 - Канальный**: `ip neighbor show` — ARP-таблица заполнена?
3. **L3 - Сетевой**: `ip route show` — есть ли шлюз по умолчанию? `ping <gateway>` — можете ли вы до него достучаться?
4. **L3 - Внешний**: `ping 8.8.8.8` — можете ли вы достичь интернета по IP?
5. **L7 - DNS**: `nslookup google.com` — работает ли разрешение DNS? Проверьте `/etc/resolv.conf`.
6. **Брандмауэр**: `iptables -L -n` или `nft list ruleset` — заблокированы ли исходящие соединения?
7. **Трассировка маршрута**: `traceroute 8.8.8.8` — где прерывается путь?
</details>

## Хранилище и файловые системы

<details>
<summary><strong>15. Что такое inode?</strong></summary>
<br>

Inode — это структура данных, хранящая метаданные о файле: права доступа, владение, размер, временные метки и указатели на блоки данных на диске. Каждый файл и каталог имеет inode.

Важно, что **имя файла НЕ хранится в inode** — оно хранится в записи каталога, которая сопоставляет имя с номером inode. Вот почему жёсткие ссылки работают: несколько записей каталога могут указывать на один и тот же inode.

Исчерпание inode (даже при наличии свободного места на диске) препятствует созданию новых файлов. Проверьте с помощью `df -i`. Распространённая причина: миллионы мелких файлов (очереди почты, каталоги кэша).
</details>

<details>
<summary><strong>16. Как расширить логический том LVM без простоя?</strong></summary>
<br>

1. Проверить доступное пространство: `vgdisplay` — искать свободные PE (physical extents).
2. Если свободного места нет, добавить новый физический диск: `pvcreate /dev/sdb && vgextend myvg /dev/sdb`.
3. Расширить логический том: `lvextend -L +10G /dev/myvg/mylv`.
4. Изменить размер файловой системы (онлайн для ext4/XFS):
   - ext4: `resize2fs /dev/myvg/mylv`
   - XFS: `xfs_growfs /mountpoint`

Размонтирование не требуется. Без простоя. Это одно из главных преимуществ LVM перед обычными разделами.
</details>

## Безопасность и укрепление

<details>
<summary><strong>17. В чём разница между su, sudo и sudoers?</strong></summary>
<br>

- **su** (switch user): Полностью переключается на другого пользователя. `su -` загружает окружение целевого пользователя. Требует пароль целевого пользователя.
- **sudo** (superuser do): Выполняет одну команду от имени другого пользователя (обычно root). Требует пароль **вызывающего**. Обеспечивает журнал аудита того, кто что выполнил.
- **sudoers** (`/etc/sudoers`): Файл конфигурации, определяющий, кто может использовать sudo и какие команды может выполнять. Безопасно редактируется с помощью `visudo` (проверка синтаксиса).

Лучшая практика: Отключить прямой вход под root (`PermitRootLogin no` в sshd_config). Вместо этого дать администраторам доступ через sudo — это обеспечивает ответственность (логирует кто что сделал) и детальный контроль.
</details>

<details>
<summary><strong>18. Как укрепить SSH-сервер?</strong></summary>
<br>

Основные изменения в `/etc/ssh/sshd_config`:
- `PermitRootLogin no` — запретить прямой вход под root.
- `PasswordAuthentication no` — принудительная аутентификация по ключам.
- `PubkeyAuthentication yes` — включить SSH-ключи.
- `Port 2222` — сменить стандартный порт (уменьшает автоматическое сканирование).
- `MaxAuthTries 3` — ограничить попытки аутентификации.
- `AllowUsers deploy admin` — белый список определённых пользователей.
- `ClientAliveInterval 300` — отключать неактивные сессии.
- Установить `fail2ban` — автоматически блокировать IP после неудачных попыток входа.
</details>

## Скриптинг и автоматизация

<details>
<summary><strong>19. В чём разница между $?, $$, $! и $@ в Bash?</strong></summary>
<br>

- **$?** — Код завершения последней команды (0 = успех, не ноль = ошибка).
- **$$** — PID текущей оболочки.
- **$!** — PID последнего фонового процесса.
- **$@** — Все аргументы, переданные скрипту (каждый как отдельное слово).
- **$#** — Количество аргументов.
- **$0** — Имя самого скрипта.
- **$1, $2, ...** — Отдельные позиционные аргументы.

Распространённый шаблон: `command && echo "success" || echo "fail"` использует `$?` неявно.
</details>

<details>
<summary><strong>20. Напишите однострочную команду для поиска всех файлов больше 100 МБ, изменённых за последние 7 дней.</strong></summary>
<br>

```bash
find / -type f -size +100M -mtime -7 -exec ls -lh {} \; 2>/dev/null
```

Разбор:
- `find /` — поиск от корня.
- `-type f` — только файлы (не каталоги).
- `-size +100M` — больше 100 мегабайт.
- `-mtime -7` — изменённые за последние 7 дней.
- `-exec ls -lh {} \;` — показать размер в удобочитаемом формате для каждого результата.
- `2>/dev/null` — подавить ошибки доступа.

Альтернатива с сортировкой: `find / -type f -size +100M -mtime -7 -printf '%s %p\n' 2>/dev/null | sort -rn | head -20`.
</details>
