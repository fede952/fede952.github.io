---
title: "مقابلة مدير أنظمة Linux: العمليات والأذونات والشبكات"
description: "20 سؤالاً أساسياً في مقابلات إدارة أنظمة Linux لأدوار مدير الأنظمة الأول وDevOps. يغطي أذونات الملفات وإدارة العمليات وsystemd والشبكات واستكشاف الأخطاء وإصلاحها."
date: 2026-02-11
tags: ["linux", "interview", "sysadmin", "devops"]
keywords: ["linux interview questions", "red hat interview", "bash scripting questions", "linux permissions interview", "sysadmin interview questions", "linux process management", "systemd interview", "linux networking questions", "senior linux engineer", "rhcsa exam prep"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "مقابلة مدير أنظمة Linux: العمليات والأذونات والشبكات",
    "description": "20 سؤالاً أساسياً في مقابلات إدارة أنظمة Linux حول الأذونات والعمليات وsystemd والشبكات.",
    "proficiencyLevel": "Advanced",
    "inLanguage": "ar"
  }
---

## تهيئة النظام

إدارة أنظمة Linux هي الأساس الذي تقوم عليه البنية التحتية الحديثة. سواء كنت تجري مقابلة لدور مدير أنظمة أو DevOps أو SRE أو مهندس سحابي، سيتم اختبارك في قدرتك على إدارة المستخدمين واستكشاف مشاكل العمليات وتكوين الشبكات وتأمين الخوادم — كل ذلك من سطر الأوامر. يغطي هذا الدليل 20 سؤالاً تفصل المرشحين ذوي الخبرة عن المبتدئين، مع إجابات تُظهر خبرة تشغيلية حقيقية.

**هل تحتاج مرجعاً سريعاً للأوامر؟** احتفظ بـ[ورقة غش مدير أنظمة Linux](/cheatsheets/linux-sysadmin-permissions/) مفتوحة أثناء تحضيرك.

---

## أذونات الملفات والملكية

<details>
<summary><strong>1. اشرح نموذج أذونات Linux (rwx، الترميز الثماني، البتات الخاصة).</strong></summary>
<br>

كل ملف لديه ثلاثة مستويات أذونات: **المالك**، **المجموعة**، **الآخرون**. كل مستوى يمكن أن يحتوي على **قراءة (r=4)**، **كتابة (w=2)**، **تنفيذ (x=1)**.

الترميز الثماني يجمع هذه القيم: `chmod 755` = rwxr-xr-x (المالك: كامل، المجموعة/الآخرون: قراءة+تنفيذ).

**البتات الخاصة**:
- **SUID (4000)**: يُنفَّذ الملف بصلاحيات مالك الملف وليس المستخدم الذي يشغّله. مثال: `/usr/bin/passwd` يعمل كـroot حتى يتمكن المستخدمون من تغيير كلمة مرورهم.
- **SGID (2000)**: على الملفات، يُنفَّذ بصلاحيات مجموعة المالك. على المجلدات، الملفات الجديدة ترث مجموعة المجلد.
- **Sticky bit (1000)**: على المجلدات، فقط مالك الملف يمكنه حذف ملفاته. المثال الكلاسيكي: `/tmp`.
</details>

<details>
<summary><strong>2. ما الفرق بين الروابط الصلبة والروابط الرمزية؟</strong></summary>
<br>

- **الرابط الصلب**: مرجع مباشر إلى inode (البيانات الفعلية على القرص). روابط صلبة متعددة لنفس الملف تتشارك نفس رقم inode. حذف رابط صلب واحد لا يؤثر على الآخرين — تبقى البيانات حتى تُحذف جميع الروابط الصلبة. لا يمكن أن يعبر حدود نظام الملفات. لا يمكن أن يشير إلى مجلدات.
- **الرابط الرمزي (symlink)**: مؤشر إلى مسار ملف (مثل اختصار). لديه inode خاص به. إذا حُذف الملف المستهدف، يصبح الرابط الرمزي رابطاً معلقاً. يمكن أن يعبر أنظمة الملفات. يمكن أن يشير إلى مجلدات.

استخدم `ls -li` لرؤية أرقام inode وتأكيد علاقات الروابط الصلبة.
</details>

<details>
<summary><strong>3. لا يستطيع مطور الكتابة في مجلد مشترك. كيف تشخّص وتصلح المشكلة؟</strong></summary>
<br>

خطوات التشخيص:
1. `ls -la /shared/` — فحص الملكية والأذونات.
2. `id developer` — فحص المجموعات التي ينتمي إليها المستخدم.
3. `getfacl /shared/` — فحص قوائم التحكم بالوصول (ACL) التي قد تتجاوز الأذونات القياسية.

الحلول الشائعة:
- إضافة المستخدم إلى مجموعة المجلد: `sudo usermod -aG devteam developer`.
- تعيين SGID على المجلد لكي ترث الملفات الجديدة المجموعة: `chmod g+s /shared/`.
- إذا كانت هناك حاجة لقوائم ACL: `setfacl -m u:developer:rwx /shared/`.
- التأكد من أن umask لا يمنع كتابة المجموعة (تحقق بأمر `umask`).
</details>

<details>
<summary><strong>4. ما هو umask وكيف يؤثر على إنشاء الملفات؟</strong></summary>
<br>

`umask` يحدد الأذونات الافتراضية **المزالة** من الملفات والمجلدات الجديدة. هو قناع بتات يُطرح من الأذونات القصوى.

- الحد الأقصى الافتراضي للملفات: 666 (بدون تنفيذ افتراضياً).
- الحد الأقصى الافتراضي للمجلدات: 777.
- مع `umask 022`: الملفات تحصل على 644 (rw-r--r--)، المجلدات تحصل على 755 (rwxr-xr-x).
- مع `umask 077`: الملفات تحصل على 600 (rw-------)، المجلدات تحصل على 700 (rwx------).

يُعيَّن على مستوى النظام في `/etc/profile` أو لكل مستخدم في `~/.bashrc`. حاسم للأمان — umask متساهل جداً قد يكشف ملفات حساسة لمستخدمين غير مصرح لهم.
</details>

## إدارة العمليات

<details>
<summary><strong>5. اشرح الفرق بين العملية والخيط والعملية الخفية.</strong></summary>
<br>

- **العملية**: نسخة من برنامج قيد التشغيل بمساحة ذاكرة خاصة وPID وواصفات ملفات وبيئة خاصة به. تُنشأ بواسطة `fork()` أو `exec()`.
- **الخيط**: وحدة تنفيذ خفيفة داخل عملية. تتشارك الخيوط نفس مساحة الذاكرة وواصفات الملفات لكن لكل منها مكدس وسجلات خاصة. أسرع في الإنشاء من العمليات.
- **العملية الخفية (Daemon)**: عملية خلفية تعمل بدون طرفية تحكم. تبدأ عادةً عند الإقلاع وتعمل باستمرار وتوفر خدمة (sshd، nginx، cron). تُسمى تقليدياً بلاحقة `d`.
</details>

<details>
<summary><strong>6. ما هي عمليات الزومبي وكيف تتعامل معها؟</strong></summary>
<br>

**الزومبي** هو عملية أنهت تنفيذها لكن لا يزال لها مدخل في جدول العمليات لأن العملية الأب لم تستدعِ `wait()` لقراءة حالة خروجها. لا تستهلك موارد سوى خانة PID.

تحديد الزومبي: `ps aux | grep Z` — تظهر الحالة `Z` (defunct).

**لا يمكنك** قتل زومبي — فهو ميت بالفعل. لإزالته:
1. أرسل `SIGCHLD` إلى العملية الأب: `kill -s SIGCHLD <parent_pid>`.
2. إذا تجاهلت العملية الأب ذلك، فإن قتل العملية الأب سيجعل الزومبي يتيماً، وسيتم تبنيه بواسطة `init` (PID 1). يستدعي init تلقائياً `wait()` وينظفه.

عدد كبير من الزومبي يشير عادةً إلى عملية أب معيبة لا تجمع عملياتها الفرعية.
</details>

<details>
<summary><strong>7. اشرح إشارات Linux. ما هي SIGTERM وSIGKILL وSIGHUP؟</strong></summary>
<br>

الإشارات هي مقاطعات برمجية تُرسل إلى العمليات:

- **SIGTERM (15)**: طلب إنهاء مهذب. يمكن للعملية التقاطها وتنظيف الموارد والخروج بأمان. هذا ما يرسله `kill <pid>` افتراضياً.
- **SIGKILL (9)**: إنهاء قسري. لا يمكن التقاطها أو حظرها أو تجاهلها. ينهي النواة العملية فوراً. استخدمها فقط كملاذ أخير — لا تنظيف ممكن.
- **SIGHUP (1)**: تاريخياً "قطع الاتصال". العديد من العمليات الخفية (nginx، Apache) تعيد تحميل تكوينها عند تلقي SIGHUP بدلاً من إعادة التشغيل.
- **SIGINT (2)**: مقاطعة، تُرسل بواسطة Ctrl+C.
- **SIGSTOP/SIGCONT (19/18)**: إيقاف مؤقت واستئناف العملية.
</details>

<details>
<summary><strong>8. كيف تجد وتنهي عملية تستهلك الكثير من CPU؟</strong></summary>
<br>

1. تحديد العملية: `top -o %CPU` أو `ps aux --sort=-%cpu | head -10`.
2. الحصول على التفاصيل: `ls -l /proc/<pid>/exe` لرؤية الملف التنفيذي الفعلي.
3. فحص ما تفعله: `strace -p <pid>` لاستدعاءات النظام، `lsof -p <pid>` للملفات المفتوحة.
4. إيقاف سلس: `kill <pid>` (SIGTERM) — السماح بالتنظيف.
5. إيقاف قسري: `kill -9 <pid>` (SIGKILL) — فقط إذا فشل SIGTERM.
6. منع التكرار: إذا كانت تُدار بواسطة systemd، عيّن `CPUQuota=50%` في ملف unit الخدمة.
</details>

## Systemd والخدمات

<details>
<summary><strong>9. ما هو systemd وكيف يختلف عن SysVinit؟</strong></summary>
<br>

**SysVinit**: عملية إقلاع تسلسلية تستخدم سكربتات shell في `/etc/init.d/`. تبدأ الخدمات واحدة تلو الأخرى في مستوى تشغيل محدد. أوقات إقلاع بطيئة. بسيط لكن محدود في إدارة التبعيات.

**systemd**: عملية إقلاع متوازية تستخدم ملفات unit. يدعم التبعيات وتفعيل المقابس وبدء الخدمات عند الطلب وcgroups للتحكم في الموارد وjournald للتسجيل. إقلاع أسرع بكثير. يدير الخدمات والمؤقتات والتثبيتات والمقابس والأهداف.

systemd هو نظام التهيئة الافتراضي على RHEL وUbuntu وDebian وFedora وSUSE وArch.
</details>

<details>
<summary><strong>10. كيف تنشئ خدمة systemd مخصصة؟</strong></summary>
<br>

أنشئ ملف unit في `/etc/systemd/system/myapp.service`:

```ini
[Unit]
Description=My Application
After=network.target

[Service]
Type=simple
User=deploy
WorkingDirectory=/opt/myapp
ExecStart=/opt/myapp/bin/server
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

ثم: `sudo systemctl daemon-reload && sudo systemctl enable --now myapp`.

القيم الرئيسية لـ`Type`: `simple` (افتراضي، العملية الرئيسية تعمل في المقدمة)، `forking` (العملية تتفرع إلى الخلفية، تحتاج `PIDFile`)، `oneshot` (تعمل مرة واحدة وتنتهي)، `notify` (العملية تُشير إلى الجاهزية عبر sd_notify).
</details>

<details>
<summary><strong>11. كيف تحلل أداء الإقلاع باستخدام systemd؟</strong></summary>
<br>

- `systemd-analyze` — وقت الإقلاع الإجمالي.
- `systemd-analyze blame` — قائمة الخدمات مرتبة حسب وقت البدء.
- `systemd-analyze critical-chain` — شجرة مسار الإقلاع الحرج.
- `systemd-analyze plot > boot.svg` — إنشاء جدول زمني مرئي لتسلسل الإقلاع.
- `journalctl -b -p err` — أخطاء الإقلاع الحالي.

لتسريع الإقلاع: تعطيل الخدمات غير الضرورية (`systemctl disable`)، تحويل الخدمات إلى تفعيل المقابس (البدء عند الطلب)، وتحديد الخدمات البطيئة من مخرجات blame.
</details>

## الشبكات

<details>
<summary><strong>12. اشرح المصافحة الثلاثية لـTCP.</strong></summary>
<br>

1. **SYN**: يرسل العميل حزمة SYN إلى الخادم مع رقم تسلسل أولي.
2. **SYN-ACK**: يستجيب الخادم بـSYN-ACK، مؤكداً SYN العميل ومرسلاً رقم تسلسله الخاص.
3. **ACK**: يرسل العميل ACK مؤكداً رقم تسلسل الخادم. تم إنشاء الاتصال.

الإنهاء يستخدم مصافحة رباعية: FIN → ACK → FIN → ACK (كل طرف يغلق نصفه من الاتصال بشكل مستقل).

التصحيح باستخدام: `ss -tuln` (المنافذ المستمعة)، `ss -tulnp` (مع أسماء العمليات)، `tcpdump -i eth0 port 80` (التقاط الحزم).
</details>

<details>
<summary><strong>13. ما الفرق بين TCP وUDP؟</strong></summary>
<br>

- **TCP** (بروتوكول التحكم بالنقل): موجه نحو الاتصال، موثوق، تسليم مرتب. يستخدم المصافحة والتأكيدات وإعادة الإرسال. حمل أعلى. يُستخدم لـHTTP وSSH وFTP وقواعد البيانات.
- **UDP** (بروتوكول مخططات بيانات المستخدم): بدون اتصال، غير موثوق، بدون ترتيب مضمون. بدون مصافحة، بدون تأكيدات. حمل أقل، تأخير أقل. يُستخدم لـDNS وDHCP وVoIP والبث والألعاب.

الفهم الأساسي: "غير موثوق" لا يعني سيئاً — يعني أن التطبيق يتعامل مع الموثوقية عند الحاجة. DNS يستخدم UDP لأن الاستعلامات صغيرة وسريعة؛ إذا فُقد الرد، يعيد العميل الإرسال ببساطة.
</details>

<details>
<summary><strong>14. لا يستطيع خادم الوصول إلى عنوان IP خارجي. كيف تستكشف المشكلة؟</strong></summary>
<br>

نهج طبقة بطبقة:
1. **L1 - الفيزيائية**: `ip link show` — هل الواجهة نشطة؟
2. **L2 - ربط البيانات**: `ip neighbor show` — هل جدول ARP مملوء؟
3. **L3 - الشبكة**: `ip route show` — هل يوجد بوابة افتراضية؟ `ping <gateway>` — هل يمكنك الوصول إليها؟
4. **L3 - خارجي**: `ping 8.8.8.8` — هل يمكنك الوصول إلى الإنترنت بواسطة IP؟
5. **L7 - DNS**: `nslookup google.com` — هل تحليل DNS يعمل؟ تحقق من `/etc/resolv.conf`.
6. **جدار الحماية**: `iptables -L -n` أو `nft list ruleset` — هل الاتصالات الصادرة محظورة؟
7. **تتبع المسار**: `traceroute 8.8.8.8` — أين ينقطع المسار؟
</details>

## التخزين وأنظمة الملفات

<details>
<summary><strong>15. ما هو inode؟</strong></summary>
<br>

inode هو بنية بيانات تخزن البيانات الوصفية لملف: الأذونات والملكية والحجم والطوابع الزمنية ومؤشرات إلى كتل البيانات على القرص. كل ملف ومجلد لديه inode.

الأمر الحاسم هو أن **اسم الملف لا يُخزَّن في inode** — يُخزَّن في مدخل المجلد الذي يربط اسماً برقم inode. لهذا تعمل الروابط الصلبة: مداخل مجلدات متعددة يمكن أن تشير إلى نفس inode.

نفاد inodes (حتى مع وجود مساحة قرص حرة) يمنع إنشاء ملفات جديدة. تحقق بـ`df -i`. السبب الشائع: ملايين الملفات الصغيرة (طوابير البريد، مجلدات التخزين المؤقت).
</details>

<details>
<summary><strong>16. كيف توسع وحدة LVM منطقية بدون توقف؟</strong></summary>
<br>

1. فحص المساحة المتاحة: `vgdisplay` — ابحث عن PE (النطاقات الفيزيائية) الحرة.
2. إذا لم تكن هناك مساحة حرة، أضف قرصاً فيزيائياً جديداً: `pvcreate /dev/sdb && vgextend myvg /dev/sdb`.
3. وسّع الوحدة المنطقية: `lvextend -L +10G /dev/myvg/mylv`.
4. غيّر حجم نظام الملفات (عبر الإنترنت لـext4/XFS):
   - ext4: `resize2fs /dev/myvg/mylv`
   - XFS: `xfs_growfs /mountpoint`

لا حاجة لإلغاء التثبيت. لا توقف. هذه إحدى المزايا الرئيسية لـLVM مقارنة بالأقسام الخام.
</details>

## الأمان والتقوية

<details>
<summary><strong>17. ما الفرق بين su وsudo وsudoers؟</strong></summary>
<br>

- **su** (تبديل المستخدم): يتحول بالكامل إلى مستخدم آخر. `su -` يحمّل بيئة المستخدم المستهدف. يتطلب كلمة مرور المستخدم المستهدف.
- **sudo** (تنفيذ كمستخدم خارق): ينفذ أمراً واحداً كمستخدم آخر (عادةً root). يتطلب كلمة مرور **المُستدعي**. يوفر تسجيل تدقيق لمن نفّذ ماذا.
- **sudoers** (`/etc/sudoers`): ملف تكوين يحدد من يمكنه استخدام sudo وأي أوامر يمكنه تنفيذها. يُحرَّر بأمان باستخدام `visudo` (التحقق من الصيغة).

أفضل الممارسات: تعطيل تسجيل الدخول المباشر كـroot (`PermitRootLogin no` في sshd_config). أعطِ المسؤولين صلاحية sudo بدلاً من ذلك — يوفر المساءلة (يسجل من فعل ماذا) والتحكم الدقيق.
</details>

<details>
<summary><strong>18. كيف تقوّي خادم SSH؟</strong></summary>
<br>

التغييرات الأساسية في `/etc/ssh/sshd_config`:
- `PermitRootLogin no` — منع تسجيل الدخول المباشر كـroot.
- `PasswordAuthentication no` — فرض المصادقة بالمفاتيح.
- `PubkeyAuthentication yes` — تمكين مفاتيح SSH.
- `Port 2222` — تغيير المنفذ الافتراضي (يقلل الفحص الآلي).
- `MaxAuthTries 3` — تحديد محاولات المصادقة.
- `AllowUsers deploy admin` — قائمة بيضاء لمستخدمين محددين.
- `ClientAliveInterval 300` — قطع الجلسات الخاملة.
- تثبيت `fail2ban` — حظر عناوين IP تلقائياً بعد محاولات تسجيل دخول فاشلة.
</details>

## البرمجة النصية والأتمتة

<details>
<summary><strong>19. ما الفرق بين $? و$$ و$! و$@ في Bash؟</strong></summary>
<br>

- **$?** — حالة خروج آخر أمر (0 = نجاح، غير صفر = فشل).
- **$$** — PID الصدفة الحالية.
- **$!** — PID آخر عملية خلفية.
- **$@** — جميع المعاملات الممررة للسكربت (كل منها ككلمة منفصلة).
- **$#** — عدد المعاملات.
- **$0** — اسم السكربت نفسه.
- **$1, $2, ...** — المعاملات الموضعية الفردية.

النمط الشائع: `command && echo "success" || echo "fail"` يستخدم `$?` ضمنياً.
</details>

<details>
<summary><strong>20. اكتب أمراً من سطر واحد للعثور على جميع الملفات الأكبر من 100 ميجابايت والمعدلة خلال آخر 7 أيام.</strong></summary>
<br>

```bash
find / -type f -size +100M -mtime -7 -exec ls -lh {} \; 2>/dev/null
```

التفصيل:
- `find /` — البحث من الجذر.
- `-type f` — ملفات فقط (ليس مجلدات).
- `-size +100M` — أكبر من 100 ميجابايت.
- `-mtime -7` — معدلة خلال آخر 7 أيام.
- `-exec ls -lh {} \;` — عرض الحجم بصيغة قابلة للقراءة لكل نتيجة.
- `2>/dev/null` — إخماد أخطاء رفض الإذن.

بديل مع الترتيب: `find / -type f -size +100M -mtime -7 -printf '%s %p\n' 2>/dev/null | sort -rn | head -20`.
</details>
