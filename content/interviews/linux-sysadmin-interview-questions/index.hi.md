---
title: "Linux SysAdmin साक्षात्कार: प्रोसेस, अनुमतियाँ और नेटवर्किंग"
description: "सीनियर SysAdmin और DevOps भूमिकाओं के लिए 20 आवश्यक Linux सिस्टम एडमिनिस्ट्रेशन साक्षात्कार प्रश्न। फ़ाइल अनुमतियाँ, प्रोसेस प्रबंधन, systemd, नेटवर्किंग और समस्या निवारण को कवर करता है।"
date: 2026-02-11
tags: ["linux", "interview", "sysadmin", "devops"]
keywords: ["linux interview questions", "red hat interview", "bash scripting questions", "linux permissions interview", "sysadmin interview questions", "linux process management", "systemd interview", "linux networking questions", "senior linux engineer", "rhcsa exam prep"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Linux SysAdmin साक्षात्कार: प्रोसेस, अनुमतियाँ और नेटवर्किंग",
    "description": "अनुमतियों, प्रोसेस, systemd और नेटवर्किंग पर 20 आवश्यक Linux सिस्टम एडमिनिस्ट्रेशन साक्षात्कार प्रश्न।",
    "proficiencyLevel": "Advanced",
    "inLanguage": "hi"
  }
---

## सिस्टम इनिशियलाइज़ेशन

Linux सिस्टम एडमिनिस्ट्रेशन आधुनिक इंफ्रास्ट्रक्चर की नींव है। चाहे आप SysAdmin, DevOps, SRE, या क्लाउड इंजीनियर की भूमिका के लिए साक्षात्कार दे रहे हों, आपको उपयोगकर्ता प्रबंधन, प्रोसेस समस्या निवारण, नेटवर्क कॉन्फ़िगरेशन और सर्वर सुरक्षा की क्षमता पर परीक्षित किया जाएगा — सब कुछ कमांड लाइन से। यह गाइड 20 प्रश्नों को कवर करता है जो सीनियर उम्मीदवारों को जूनियर से अलग करते हैं, ऐसे उत्तरों के साथ जो वास्तविक परिचालन अनुभव दर्शाते हैं।

**त्वरित कमांड रेफरेंस चाहिए?** तैयारी के दौरान हमारी [Linux SysAdmin चीटशीट](/cheatsheets/linux-sysadmin-permissions/) खुली रखें।

---

## फ़ाइल अनुमतियाँ और स्वामित्व

<details>
<summary><strong>1. Linux अनुमति मॉडल (rwx, ऑक्टल नोटेशन, विशेष बिट्स) समझाइए।</strong></summary>
<br>

प्रत्येक फ़ाइल में तीन अनुमति स्तर होते हैं: **स्वामी**, **समूह**, **अन्य**। प्रत्येक स्तर में **पढ़ना (r=4)**, **लिखना (w=2)**, **निष्पादन (x=1)** हो सकता है।

ऑक्टल नोटेशन इन्हें जोड़ता है: `chmod 755` = rwxr-xr-x (स्वामी: पूर्ण, समूह/अन्य: पढ़ना+निष्पादन)।

**विशेष बिट्स**:
- **SUID (4000)**: फ़ाइल चलाने वाले उपयोगकर्ता के बजाय फ़ाइल स्वामी के रूप में निष्पादित होती है। उदाहरण: `/usr/bin/passwd` root के रूप में चलता है ताकि उपयोगकर्ता अपना पासवर्ड बदल सकें।
- **SGID (2000)**: फ़ाइलों पर, समूह स्वामी के रूप में निष्पादित होता है। डायरेक्टरी पर, नई फ़ाइलें डायरेक्टरी का समूह इनहेरिट करती हैं।
- **Sticky bit (1000)**: डायरेक्टरी पर, केवल फ़ाइल स्वामी ही अपनी फ़ाइलें हटा सकता है। क्लासिक उदाहरण: `/tmp`।
</details>

<details>
<summary><strong>2. हार्ड लिंक और सॉफ्ट लिंक में क्या अंतर है?</strong></summary>
<br>

- **हार्ड लिंक**: inode (डिस्क पर वास्तविक डेटा) का सीधा संदर्भ। एक ही फ़ाइल के कई हार्ड लिंक एक ही inode नंबर साझा करते हैं। एक हार्ड लिंक हटाने से दूसरों पर कोई प्रभाव नहीं पड़ता — डेटा तब तक बना रहता है जब तक सभी हार्ड लिंक हटा नहीं दिए जाते। फ़ाइल सिस्टम सीमाओं को पार नहीं कर सकता। डायरेक्टरी से लिंक नहीं कर सकता।
- **सॉफ्ट लिंक (symlink)**: फ़ाइल पथ का एक पॉइंटर (शॉर्टकट की तरह)। इसका अपना inode होता है। यदि लक्ष्य फ़ाइल हटा दी जाती है, तो symlink एक डैंगलिंग लिंक बन जाता है। फ़ाइल सिस्टम पार कर सकता है। डायरेक्टरी से लिंक कर सकता है।

inode नंबर देखने और हार्ड लिंक संबंधों की पुष्टि करने के लिए `ls -li` का उपयोग करें।
</details>

<details>
<summary><strong>3. एक डेवलपर साझा डायरेक्टरी में लिख नहीं सकता। आप कैसे निदान और समाधान करेंगे?</strong></summary>
<br>

निदान चरण:
1. `ls -la /shared/` — स्वामित्व और अनुमतियाँ जाँचें।
2. `id developer` — जाँचें कि उपयोगकर्ता किन समूहों से संबंधित है।
3. `getfacl /shared/` — ऐसे ACL जाँचें जो मानक अनुमतियों को ओवरराइड कर सकते हैं।

सामान्य समाधान:
- उपयोगकर्ता को डायरेक्टरी के समूह में जोड़ें: `sudo usermod -aG devteam developer`।
- डायरेक्टरी पर SGID सेट करें ताकि नई फ़ाइलें समूह इनहेरिट करें: `chmod g+s /shared/`।
- यदि ACL की आवश्यकता है: `setfacl -m u:developer:rwx /shared/`।
- सुनिश्चित करें कि umask समूह लिखने को ब्लॉक नहीं कर रहा (`umask` कमांड से जाँचें)।
</details>

<details>
<summary><strong>4. umask क्या है और यह फ़ाइल निर्माण को कैसे प्रभावित करता है?</strong></summary>
<br>

`umask` नई फ़ाइलों और डायरेक्टरी से **हटाई जाने वाली** डिफ़ॉल्ट अनुमतियों को परिभाषित करता है। यह अधिकतम अनुमतियों से घटाया जाने वाला बिटमास्क है।

- फ़ाइलों के लिए डिफ़ॉल्ट अधिकतम: 666 (डिफ़ॉल्ट रूप से कोई निष्पादन नहीं)।
- डायरेक्टरी के लिए डिफ़ॉल्ट अधिकतम: 777।
- `umask 022` के साथ: फ़ाइलें 644 (rw-r--r--) पाती हैं, डायरेक्टरी 755 (rwxr-xr-x) पाती हैं।
- `umask 077` के साथ: फ़ाइलें 600 (rw-------) पाती हैं, डायरेक्टरी 700 (rwx------) पाती हैं।

सिस्टम-वाइड `/etc/profile` में या प्रति-उपयोगकर्ता `~/.bashrc` में सेट करें। सुरक्षा के लिए महत्वपूर्ण — एक अनुमतिपूर्ण umask संवेदनशील फ़ाइलों को अनधिकृत उपयोगकर्ताओं के सामने उजागर कर सकता है।
</details>

## प्रोसेस प्रबंधन

<details>
<summary><strong>5. प्रोसेस, थ्रेड और डेमन में अंतर समझाइए।</strong></summary>
<br>

- **प्रोसेस**: एक चल रहे प्रोग्राम का इंस्टेंस जिसका अपना मेमोरी स्पेस, PID, फ़ाइल डिस्क्रिप्टर और एनवायरनमेंट होता है। `fork()` या `exec()` द्वारा बनाया जाता है।
- **थ्रेड**: एक प्रोसेस के भीतर एक हल्की निष्पादन इकाई। थ्रेड्स एक ही मेमोरी स्पेस और फ़ाइल डिस्क्रिप्टर साझा करते हैं लेकिन अपना स्वयं का स्टैक और रजिस्टर रखते हैं। प्रोसेस की तुलना में तेज़ बनते हैं।
- **डेमन**: एक बैकग्राउंड प्रोसेस जो बिना कंट्रोलिंग टर्मिनल के चलती है। आमतौर पर बूट पर शुरू होती है, लगातार चलती है और एक सेवा प्रदान करती है (sshd, nginx, cron)। परंपरागत रूप से `d` प्रत्यय से नामित।
</details>

<details>
<summary><strong>6. ज़ॉम्बी प्रोसेस क्या हैं और आप उन्हें कैसे संभालते हैं?</strong></summary>
<br>

एक **ज़ॉम्बी** वह प्रोसेस है जिसने निष्पादन पूरा कर लिया है लेकिन अभी भी प्रोसेस टेबल में एक एंट्री है क्योंकि इसके पैरेंट ने इसके एग्ज़िट स्टेटस को पढ़ने के लिए `wait()` कॉल नहीं किया। यह PID स्लॉट के अलावा कोई संसाधन नहीं खपत करता।

ज़ॉम्बी पहचानें: `ps aux | grep Z` — वे स्टेटस `Z` (defunct) दिखाते हैं।

आप ज़ॉम्बी को **kill नहीं कर सकते** — यह पहले से मृत है। इसे हटाने के लिए:
1. पैरेंट प्रोसेस को `SIGCHLD` भेजें: `kill -s SIGCHLD <parent_pid>`।
2. यदि पैरेंट इसे अनदेखा करता है, तो पैरेंट प्रोसेस को kill करने से ज़ॉम्बी अनाथ हो जाएगा, जिसे `init` (PID 1) द्वारा अपनाया जाएगा। Init स्वचालित रूप से `wait()` कॉल करता है और इसे साफ़ करता है।

बड़ी संख्या में ज़ॉम्बी आमतौर पर एक दोषपूर्ण पैरेंट प्रोसेस को इंगित करते हैं जो अपने चाइल्ड प्रोसेस को एकत्र नहीं कर रहा।
</details>

<details>
<summary><strong>7. Linux सिग्नल समझाइए। SIGTERM, SIGKILL और SIGHUP क्या हैं?</strong></summary>
<br>

सिग्नल प्रोसेस को भेजे जाने वाले सॉफ़्टवेयर इंटरप्ट हैं:

- **SIGTERM (15)**: विनम्र समाप्ति अनुरोध। प्रोसेस इसे पकड़ सकता है, संसाधनों को साफ़ कर सकता है और सुचारू रूप से बाहर निकल सकता है। यही `kill <pid>` डिफ़ॉल्ट रूप से भेजता है।
- **SIGKILL (9)**: बलपूर्वक समाप्ति। पकड़ा, ब्लॉक या अनदेखा नहीं किया जा सकता। कर्नेल प्रोसेस को तुरंत समाप्त करता है। केवल अंतिम उपाय के रूप में उपयोग करें — कोई सफ़ाई संभव नहीं।
- **SIGHUP (1)**: ऐतिहासिक रूप से "हैंगअप"। कई डेमन (nginx, Apache) SIGHUP प्राप्त करने पर पुनः प्रारंभ करने के बजाय अपना कॉन्फ़िगरेशन रीलोड करते हैं।
- **SIGINT (2)**: इंटरप्ट, Ctrl+C द्वारा भेजा जाता है।
- **SIGSTOP/SIGCONT (19/18)**: प्रोसेस को रोकें और फिर से शुरू करें।
</details>

<details>
<summary><strong>8. बहुत अधिक CPU खपत करने वाले प्रोसेस को कैसे खोजें और समाप्त करें?</strong></summary>
<br>

1. प्रोसेस पहचानें: `top -o %CPU` या `ps aux --sort=-%cpu | head -10`।
2. विवरण प्राप्त करें: `ls -l /proc/<pid>/exe` वास्तविक बाइनरी देखने के लिए।
3. जाँचें यह क्या कर रहा है: `strace -p <pid>` सिस्टम कॉल के लिए, `lsof -p <pid>` खुली फ़ाइलों के लिए।
4. सुचारू रोक: `kill <pid>` (SIGTERM) — सफ़ाई की अनुमति दें।
5. बलपूर्वक रोक: `kill -9 <pid>` (SIGKILL) — केवल अगर SIGTERM विफल हो।
6. पुनरावृत्ति रोकें: यदि systemd द्वारा प्रबंधित है, तो सर्विस unit फ़ाइल में `CPUQuota=50%` सेट करें।
</details>

## Systemd और सेवाएँ

<details>
<summary><strong>9. systemd क्या है और यह SysVinit से कैसे भिन्न है?</strong></summary>
<br>

**SysVinit**: `/etc/init.d/` में शेल स्क्रिप्ट का उपयोग करने वाली क्रमिक बूट प्रक्रिया। सेवाएँ एक परिभाषित रन लेवल में एक के बाद एक शुरू होती हैं। धीमा बूट समय। सरल लेकिन सीमित निर्भरता प्रबंधन।

**systemd**: unit फ़ाइलों का उपयोग करने वाली समानांतर बूट प्रक्रिया। निर्भरताएँ, सॉकेट एक्टिवेशन, ऑन-डिमांड सर्विस स्टार्टिंग, संसाधन नियंत्रण के लिए cgroups और लॉगिंग के लिए journald का समर्थन करता है। बहुत तेज़ बूट। सेवाएँ, टाइमर, माउंट, सॉकेट और टारगेट प्रबंधित करता है।

systemd RHEL, Ubuntu, Debian, Fedora, SUSE और Arch पर डिफ़ॉल्ट init सिस्टम है।
</details>

<details>
<summary><strong>10. कस्टम systemd सर्विस कैसे बनाएँ?</strong></summary>
<br>

`/etc/systemd/system/myapp.service` में एक unit फ़ाइल बनाएँ:

```ini
[Unit]
Description=My Application
After=network.target

[Service]
Type=simple
User=deploy
WorkingDirectory=/opt/myapp
ExecStart=/opt/myapp/bin/server
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

फिर: `sudo systemctl daemon-reload && sudo systemctl enable --now myapp`।

`Type` के प्रमुख मान: `simple` (डिफ़ॉल्ट, मुख्य प्रोसेस फ़ोरग्राउंड में चलती है), `forking` (प्रोसेस बैकग्राउंड में फ़ॉर्क होती है, `PIDFile` चाहिए), `oneshot` (एक बार चलती है और समाप्त होती है), `notify` (प्रोसेस sd_notify के माध्यम से तत्परता का संकेत देती है)।
</details>

<details>
<summary><strong>11. systemd के साथ बूट प्रदर्शन का विश्लेषण कैसे करें?</strong></summary>
<br>

- `systemd-analyze` — कुल बूट समय।
- `systemd-analyze blame` — स्टार्ट समय के अनुसार क्रमबद्ध सेवाओं की सूची।
- `systemd-analyze critical-chain` — क्रिटिकल बूट पथ का ट्री।
- `systemd-analyze plot > boot.svg` — बूट अनुक्रम की विज़ुअल टाइमलाइन जनरेट करें।
- `journalctl -b -p err` — वर्तमान बूट की त्रुटियाँ।

बूट तेज़ करने के लिए: अनावश्यक सेवाएँ अक्षम करें (`systemctl disable`), सेवाओं को सॉकेट एक्टिवेशन पर स्विच करें (ऑन-डिमांड स्टार्ट), और blame आउटपुट से धीमी सेवाओं की पहचान करें।
</details>

## नेटवर्किंग

<details>
<summary><strong>12. TCP तीन-तरफ़ा हैंडशेक समझाइए।</strong></summary>
<br>

1. **SYN**: क्लाइंट सर्वर को प्रारंभिक अनुक्रम संख्या के साथ SYN पैकेट भेजता है।
2. **SYN-ACK**: सर्वर SYN-ACK के साथ प्रतिक्रिया करता है, क्लाइंट के SYN को स्वीकार करता है और अपना अनुक्रम संख्या भेजता है।
3. **ACK**: क्लाइंट सर्वर के अनुक्रम संख्या की पुष्टि करते हुए ACK भेजता है। कनेक्शन स्थापित हो गया।

टियरडाउन चार-तरफ़ा हैंडशेक का उपयोग करता है: FIN → ACK → FIN → ACK (प्रत्येक पक्ष स्वतंत्र रूप से कनेक्शन का अपना आधा हिस्सा बंद करता है)।

डीबग: `ss -tuln` (सुनने वाले पोर्ट), `ss -tulnp` (प्रोसेस नामों के साथ), `tcpdump -i eth0 port 80` (पैकेट कैप्चर)।
</details>

<details>
<summary><strong>13. TCP और UDP में क्या अंतर है?</strong></summary>
<br>

- **TCP** (Transmission Control Protocol): कनेक्शन-उन्मुख, विश्वसनीय, क्रमबद्ध डिलीवरी। हैंडशेक, पावती, पुनः प्रसारण का उपयोग करता है। अधिक ओवरहेड। HTTP, SSH, FTP, डेटाबेस के लिए उपयोग होता है।
- **UDP** (User Datagram Protocol): कनेक्शन-रहित, अविश्वसनीय, कोई गारंटीकृत क्रम नहीं। कोई हैंडशेक नहीं, कोई पावती नहीं। कम ओवरहेड, कम लेटेंसी। DNS, DHCP, VoIP, स्ट्रीमिंग, गेमिंग के लिए उपयोग होता है।

मुख्य अंतर्दृष्टि: "अविश्वसनीय" का मतलब खराब नहीं है — इसका मतलब है कि एप्लिकेशन ज़रूरत पड़ने पर विश्वसनीयता स्वयं संभालता है। DNS UDP का उपयोग करता है क्योंकि क्वेरी छोटी और तेज़ होती हैं; यदि प्रतिक्रिया खो जाती है, तो क्लाइंट बस पुनः भेजता है।
</details>

<details>
<summary><strong>14. एक सर्वर बाहरी IP तक नहीं पहुँच सकता। आप कैसे समस्या निवारण करेंगे?</strong></summary>
<br>

परत-दर-परत दृष्टिकोण:
1. **L1 - भौतिक**: `ip link show` — क्या इंटरफ़ेस सक्रिय है?
2. **L2 - डेटा लिंक**: `ip neighbor show` — क्या ARP टेबल भरी है?
3. **L3 - नेटवर्क**: `ip route show` — क्या डिफ़ॉल्ट गेटवे है? `ping <gateway>` — क्या आप उस तक पहुँच सकते हैं?
4. **L3 - बाहरी**: `ping 8.8.8.8` — क्या आप IP द्वारा इंटरनेट तक पहुँच सकते हैं?
5. **L7 - DNS**: `nslookup google.com` — क्या DNS रिज़ॉल्यूशन काम कर रहा है? `/etc/resolv.conf` जाँचें।
6. **फ़ायरवॉल**: `iptables -L -n` या `nft list ruleset` — क्या आउटबाउंड कनेक्शन ब्लॉक हैं?
7. **रूट ट्रेस**: `traceroute 8.8.8.8` — पथ कहाँ टूटता है?
</details>

## स्टोरेज और फ़ाइल सिस्टम

<details>
<summary><strong>15. inode क्या है?</strong></summary>
<br>

inode एक डेटा स्ट्रक्चर है जो फ़ाइल के बारे में मेटाडेटा स्टोर करता है: अनुमतियाँ, स्वामित्व, आकार, टाइमस्टैम्प, और डिस्क पर डेटा ब्लॉक के पॉइंटर। प्रत्येक फ़ाइल और डायरेक्टरी का एक inode होता है।

महत्वपूर्ण बात यह है कि **फ़ाइल का नाम inode में स्टोर नहीं होता** — यह डायरेक्टरी एंट्री में स्टोर होता है, जो एक नाम को inode नंबर से मैप करता है। यही कारण है कि हार्ड लिंक काम करते हैं: एकाधिक डायरेक्टरी एंट्री एक ही inode की ओर इशारा कर सकती हैं।

inode समाप्त होना (डिस्क पर खाली जगह होने पर भी) नई फ़ाइलें बनाने से रोकता है। `df -i` से जाँचें। सामान्य कारण: लाखों छोटी फ़ाइलें (मेल कतारें, कैश डायरेक्टरी)।
</details>

<details>
<summary><strong>16. बिना डाउनटाइम के LVM लॉजिकल वॉल्यूम कैसे विस्तारित करें?</strong></summary>
<br>

1. उपलब्ध स्थान जाँचें: `vgdisplay` — मुक्त PE (physical extents) देखें।
2. यदि कोई मुक्त स्थान नहीं है, एक नई भौतिक डिस्क जोड़ें: `pvcreate /dev/sdb && vgextend myvg /dev/sdb`।
3. लॉजिकल वॉल्यूम विस्तारित करें: `lvextend -L +10G /dev/myvg/mylv`।
4. फ़ाइल सिस्टम का आकार बदलें (ext4/XFS के लिए ऑनलाइन):
   - ext4: `resize2fs /dev/myvg/mylv`
   - XFS: `xfs_growfs /mountpoint`

अनमाउंट की ज़रूरत नहीं। कोई डाउनटाइम नहीं। यह रॉ पार्टिशन पर LVM के प्रमुख लाभों में से एक है।
</details>

## सुरक्षा और हार्डनिंग

<details>
<summary><strong>17. su, sudo और sudoers में क्या अंतर है?</strong></summary>
<br>

- **su** (switch user): पूरी तरह से दूसरे उपयोगकर्ता में बदलता है। `su -` लक्ष्य उपयोगकर्ता का एनवायरनमेंट लोड करता है। लक्ष्य उपयोगकर्ता का पासवर्ड आवश्यक है।
- **sudo** (superuser do): दूसरे उपयोगकर्ता (आमतौर पर root) के रूप में एक कमांड चलाता है। **कॉलर** का पासवर्ड आवश्यक है। किसने क्या चलाया इसका ऑडिट लॉग प्रदान करता है।
- **sudoers** (`/etc/sudoers`): कॉन्फ़िगरेशन फ़ाइल जो परिभाषित करती है कि कौन sudo का उपयोग कर सकता है और कौन से कमांड चला सकता है। `visudo` (सिंटैक्स सत्यापन) से सुरक्षित रूप से संपादित किया जाता है।

सर्वोत्तम अभ्यास: सीधा root लॉगिन अक्षम करें (sshd_config में `PermitRootLogin no`)। इसके बजाय एडमिन को sudo एक्सेस दें — यह जवाबदेही (किसने क्या किया इसका लॉग) और विस्तृत नियंत्रण प्रदान करता है।
</details>

<details>
<summary><strong>18. SSH सर्वर को कैसे हार्डन करें?</strong></summary>
<br>

`/etc/ssh/sshd_config` में आवश्यक परिवर्तन:
- `PermitRootLogin no` — सीधा root लॉगिन रोकें।
- `PasswordAuthentication no` — कुंजी-आधारित प्रमाणीकरण बाध्य करें।
- `PubkeyAuthentication yes` — SSH कुंजियाँ सक्षम करें।
- `Port 2222` — डिफ़ॉल्ट पोर्ट बदलें (स्वचालित स्कैन कम करता है)।
- `MaxAuthTries 3` — प्रमाणीकरण प्रयास सीमित करें।
- `AllowUsers deploy admin` — विशिष्ट उपयोगकर्ताओं की व्हाइटलिस्ट।
- `ClientAliveInterval 300` — निष्क्रिय सत्र डिस्कनेक्ट करें।
- `fail2ban` इंस्टॉल करें — विफल लॉगिन प्रयासों के बाद IP स्वचालित रूप से प्रतिबंधित करें।
</details>

## स्क्रिप्टिंग और ऑटोमेशन

<details>
<summary><strong>19. Bash में $?, $$, $! और $@ में क्या अंतर है?</strong></summary>
<br>

- **$?** — अंतिम कमांड का एग्ज़िट स्टेटस (0 = सफलता, गैर-शून्य = विफलता)।
- **$$** — वर्तमान शेल का PID।
- **$!** — अंतिम बैकग्राउंड प्रोसेस का PID।
- **$@** — स्क्रिप्ट को पास किए गए सभी तर्क (प्रत्येक अलग शब्द के रूप में)।
- **$#** — तर्कों की संख्या।
- **$0** — स्क्रिप्ट का नाम।
- **$1, $2, ...** — व्यक्तिगत स्थितीय तर्क।

सामान्य पैटर्न: `command && echo "success" || echo "fail"` अंतर्निहित रूप से `$?` का उपयोग करता है।
</details>

<details>
<summary><strong>20. पिछले 7 दिनों में संशोधित 100MB से बड़ी सभी फ़ाइलें खोजने के लिए एक वन-लाइनर लिखिए।</strong></summary>
<br>

```bash
find / -type f -size +100M -mtime -7 -exec ls -lh {} \; 2>/dev/null
```

विश्लेषण:
- `find /` — रूट से खोजें।
- `-type f` — केवल फ़ाइलें (डायरेक्टरी नहीं)।
- `-size +100M` — 100 मेगाबाइट से बड़ी।
- `-mtime -7` — पिछले 7 दिनों में संशोधित।
- `-exec ls -lh {} \;` — प्रत्येक परिणाम के लिए मानव-पठनीय आकार दिखाएँ।
- `2>/dev/null` — अनुमति अस्वीकृत त्रुटियाँ दबाएँ।

सॉर्ट के साथ विकल्प: `find / -type f -size +100M -mtime -7 -printf '%s %p\n' 2>/dev/null | sort -rn | head -20`।
</details>
