---
title: "أهم 20 سؤالاً وإجابة في مقابلات Docker (إصدار 2026)"
description: "اجتز مقابلة Senior DevOps بنجاح مع هذه الأسئلة العشرين المتقدمة حول Docker التي تغطي الحاويات والصور والشبكات والمجلدات وDocker Compose وأفضل ممارسات الإنتاج."
date: 2026-02-11
tags: ["docker", "interview", "devops", "containers"]
keywords: ["أسئلة مقابلة docker", "مقابلة senior devops", "أسئلة الحاويات", "إجابات مقابلة docker", "مقابلة docker compose", "أفضل ممارسات dockerfile", "مقابلة تنسيق الحاويات", "أسئلة شبكات docker", "مقابلة مهندس devops", "أسئلة docker الإنتاج"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "أهم 20 سؤالاً وإجابة في مقابلات Docker (إصدار 2026)",
    "description": "أسئلة مقابلات Docker المتقدمة لأدوار Senior DevOps تغطي الحاويات والصور والشبكات وأفضل ممارسات الإنتاج.",
    "proficiencyLevel": "Advanced",
    "inLanguage": "ar"
  }
---

## تهيئة النظام

أصبح Docker مهارة لا غنى عنها لأي دور في DevOps أو SRE أو هندسة الخلفية. يتوقع المحاورون على المستوى الأول أن تتجاوز `docker run` — يريدون رؤية أنك تفهم طبقات الصور وآليات الشبكات الداخلية وتعزيز الأمان وأنماط التنسيق للإنتاج. يحتوي هذا الدليل على الأسئلة العشرين الأكثر شيوعاً في مقابلات مستوى Senior وLead، مع إجابات مفصلة تُظهر العمق.

**هل تحتاج لمراجعة سريعة للأوامر قبل المقابلة؟** احفظ في المفضلة [ورقة غش Docker Captain's Log](/cheatsheets/docker-container-commands/).

---

## المفاهيم الأساسية

<details>
<summary><strong>1. ما الفرق بين الحاوية والآلة الافتراضية؟</strong></summary>
<br>

تقوم **الآلة الافتراضية** بتشغيل نظام تشغيل ضيف كامل فوق مشرف افتراضي، بما في ذلك نواتها الخاصة وبرامج التشغيل ومكتبات النظام. كل آلة افتراضية معزولة تماماً لكنها تستهلك موارد كبيرة (غيغابايت من ذاكرة الوصول العشوائي، دقائق للإقلاع).

تشارك **الحاوية** نواة نظام التشغيل المضيف وتعزل العمليات باستخدام مساحات أسماء Linux ومجموعات التحكم (cgroups). تحزم فقط التطبيق وتبعياته — بدون نواة منفصلة. هذا يجعل الحاويات خفيفة الوزن (ميغابايت)، سريعة البدء (ملي ثانية)، وعالية القابلية للنقل.

الفرق الرئيسي: الآلات الافتراضية تجعل **العتاد** افتراضياً، الحاويات تجعل **نظام التشغيل** افتراضياً.
</details>

<details>
<summary><strong>2. ما هي طبقات صور Docker وكيف تعمل؟</strong></summary>
<br>

تُبنى صورة Docker من سلسلة من **الطبقات للقراءة فقط**. كل تعليمة في Dockerfile (`FROM`، `RUN`، `COPY`، إلخ) تنشئ طبقة جديدة. تُكدّس الطبقات فوق بعضها باستخدام نظام ملفات اتحادي (مثل OverlayFS).

عند تشغيل حاوية، يضيف Docker **طبقة قابلة للكتابة** رقيقة في الأعلى (طبقة الحاوية). التغييرات التي تتم أثناء التشغيل تؤثر فقط على هذه الطبقة القابلة للكتابة — طبقات الصورة الأساسية تبقى دون تغيير.

هذه البنية تمكّن من:
- **التخزين المؤقت**: إذا لم تتغير طبقة، يعيد Docker استخدامها من الذاكرة المؤقتة أثناء البناء.
- **المشاركة**: حاويات متعددة من نفس الصورة تشارك الطبقات للقراءة فقط، مما يوفر مساحة القرص.
- **الكفاءة**: فقط الطبقات المعدلة تحتاج إلى السحب أو الدفع إلى السجلات.
</details>

<details>
<summary><strong>3. ما الفرق بين CMD وENTRYPOINT في Dockerfile؟</strong></summary>
<br>

كلاهما يحدد ما يتم تشغيله عند بدء الحاوية، لكنهما يتصرفان بشكل مختلف:

- **CMD** يوفر وسائط افتراضية يمكن استبدالها بالكامل أثناء التشغيل. إذا نفذت `docker run myimage /bin/bash`، يتم استبدال CMD.
- **ENTRYPOINT** يحدد الملف التنفيذي الرئيسي الذي يعمل دائماً. وسائط وقت التشغيل تُضاف إليه، ولا تستبدله.

أفضل ممارسة: استخدم `ENTRYPOINT` للعملية الرئيسية و`CMD` للوسائط الافتراضية:

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD ["--port", "8080"]
```

تنفيذ `docker run myimage --port 3000` سينفذ `python app.py --port 3000`.
</details>

<details>
<summary><strong>4. ما هو البناء متعدد المراحل ولماذا هو مهم؟</strong></summary>
<br>

البناء متعدد المراحل يستخدم تعليمات `FROM` متعددة في Dockerfile واحد. كل `FROM` يبدأ مرحلة بناء جديدة، ويمكنك نسخ الأدوات بشكل انتقائي من مرحلة إلى أخرى.

```dockerfile
# Stage 1: Build
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# Stage 2: Run (minimal image)
FROM alpine:3.18
COPY --from=builder /app/myapp /usr/local/bin/
CMD ["myapp"]
```

هذا ينتج صورة نهائية تحتوي فقط على الملف الثنائي المُجمّع — بدون أدوات بناء، بدون شفرة مصدرية، بدون ملفات وسيطة. النتيجة صورة أصغر بشكل كبير (غالباً 10-100 مرة أصغر) مع سطح هجوم مُختزل.
</details>

<details>
<summary><strong>5. ما الفرق بين COPY وADD في Dockerfile؟</strong></summary>
<br>

كلاهما ينسخ الملفات من سياق البناء إلى الصورة، لكن `ADD` له ميزات إضافية:
- `ADD` يمكنه استخراج أرشيفات `.tar` المحلية تلقائياً.
- `ADD` يمكنه تنزيل الملفات من عناوين URL.

ومع ذلك، توصي أفضل ممارسات Docker باستخدام `COPY` في جميع الحالات تقريباً لأنه صريح ويمكن التنبؤ به. استخدم `ADD` فقط عندما تحتاج تحديداً لاستخراج tar. لا تستخدم أبداً `ADD` لتنزيل الملفات — استخدم `RUN curl` أو `RUN wget` بدلاً من ذلك، حتى يمكن تخزين طبقة التنزيل مؤقتاً بشكل صحيح.
</details>

## الشبكات

<details>
<summary><strong>6. اشرح أوضاع شبكات Docker (bridge، host، none، overlay).</strong></summary>
<br>

- **Bridge** (الافتراضي): ينشئ شبكة داخلية خاصة على المضيف. الحاويات على نفس الجسر يمكنها التواصل عبر IP أو اسم الحاوية. حركة المرور إلى الخارج تتطلب تعيين المنافذ (`-p`).
- **Host**: يزيل عزل الشبكة. تشارك الحاوية مكدس شبكة المضيف مباشرة. لا حاجة لتعيين المنافذ، لكن لا عزل أيضاً. مفيد للتطبيقات ذات المتطلبات الحرجة للأداء.
- **None**: لا شبكة على الإطلاق. الحاوية لديها فقط واجهة الاسترجاع. يُستخدم للمهام الدُفعية أو أعباء العمل الحساسة أمنياً.
- **Overlay**: يمتد عبر مضيفات Docker متعددة (يُستخدم في Swarm/Kubernetes). الحاويات على أجهزة مختلفة يمكنها التواصل كما لو كانت على نفس الشبكة، باستخدام نفق VXLAN.
</details>

<details>
<summary><strong>7. كيف يعمل التواصل بين الحاويات؟</strong></summary>
<br>

على شبكة bridge معرّفة من المستخدم، يمكن للحاويات الوصول لبعضها **باسم الحاوية** عبر محلل DNS المدمج في Docker. خادم DNS يعمل على `127.0.0.11` داخل كل حاوية.

على شبكة bridge الافتراضية، تحليل DNS **غير متاح** — يمكن للحاويات التواصل فقط عبر عنوان IP، وهو غير موثوق لأن عناوين IP تُعيّن ديناميكياً.

أفضل ممارسة: أنشئ دائماً شبكة bridge مخصصة (`docker network create mynet`) واربط الحاويات بها. لا تعتمد أبداً على الجسر الافتراضي للتواصل بين الحاويات.
</details>

<details>
<summary><strong>8. ما الفرق بين EXPOSE ونشر منفذ؟</strong></summary>
<br>

`EXPOSE` في Dockerfile هو مجرد **توثيق** — يخبر أي شخص يقرأ Dockerfile أن التطبيق يستمع على منفذ محدد. لا يفتح أو يعيّن المنفذ فعلياً.

نشر منفذ (`-p 8080:80`) ينشئ فعلياً قاعدة شبكة تعيّن منفذ المضيف إلى منفذ الحاوية، مما يجعل الخدمة متاحة من خارج الحاوية.

يمكنك نشر منافذ غير موجودة في توجيه `EXPOSE`، و`EXPOSE` وحده لا يفعل شيئاً بدون `-p`.
</details>

## المجلدات والتخزين

<details>
<summary><strong>9. ما هي أنواع التثبيت الثلاثة في Docker؟</strong></summary>
<br>

1. **المجلدات** (`docker volume create`): يديرها Docker، تُخزّن في `/var/lib/docker/volumes/`. الأفضل للبيانات الدائمة (قواعد البيانات). تبقى بعد حذف الحاوية. قابلة للنقل بين المضيفات.
2. **التثبيتات المرتبطة** (`-v /host/path:/container/path`): تعيّن مجلد مضيف محدد إلى الحاوية. يجب أن يكون مسار المضيف موجوداً. الأفضل للتطوير (إعادة تحميل الكود المباشر). غير قابلة للنقل.
3. **تثبيتات tmpfs** (`--tmpfs /tmp`): تُخزّن في ذاكرة المضيف فقط. لا تُكتب أبداً على القرص. الأفضل للبيانات الحساسة التي لا ينبغي أن تبقى (الأسرار، رموز الجلسة).
</details>

<details>
<summary><strong>10. كيف تحافظ على بيانات حاوية قاعدة البيانات؟</strong></summary>
<br>

استخدم **مجلداً مسمى** مثبتاً على مجلد بيانات قاعدة البيانات:

```bash
docker volume create pgdata
docker run -d -v pgdata:/var/lib/postgresql/data postgres:16
```

البيانات تبقى بعد إعادة تشغيل وحذف الحاوية. عند ترقية إصدار قاعدة البيانات، أوقف الحاوية القديمة، ابدأ واحدة جديدة بنفس المجلد، ودع الإصدار الجديد يتعامل مع ترحيل البيانات.

لا تستخدم أبداً التثبيتات المرتبطة لقواعد بيانات الإنتاج — المجلدات لديها أداء أفضل للإدخال/الإخراج ويديرها محرك تخزين Docker.
</details>

## الأمان

<details>
<summary><strong>11. كيف تؤمّن حاوية Docker في الإنتاج؟</strong></summary>
<br>

ممارسات التعزيز الرئيسية:
- **التشغيل كغير root**: استخدم توجيه `USER` في Dockerfile. لا تشغل أبداً عمليات التطبيق كـ root.
- **استخدام صور أساسية بحد أدنى**: `alpine` أو `distroless` أو `scratch` بدلاً من `ubuntu`.
- **إسقاط القدرات**: استخدم `--cap-drop ALL --cap-add <المطلوب-فقط>`.
- **نظام ملفات للقراءة فقط**: استخدم `--read-only` وثبّت فقط المسارات القابلة للكتابة المحددة.
- **بدون امتيازات جديدة**: استخدم `--security-opt=no-new-privileges`.
- **فحص الصور**: استخدم `docker scout` أو Trivy أو Snyk للكشف عن الثغرات في الصور الأساسية والتبعيات.
- **توقيع الصور**: استخدم Docker Content Trust (`DOCKER_CONTENT_TRUST=1`) للتحقق من أصالة الصور.
- **تحديد الموارد**: استخدم `--memory` و`--cpus` لمنع استنفاد الموارد.
</details>

<details>
<summary><strong>12. ما هو وضع Docker بدون صلاحيات الجذر (rootless)؟</strong></summary>
<br>

يشغّل وضع Docker بدون صلاحيات الجذر عفريت Docker والحاويات بالكامل داخل مساحة اسم مستخدم، دون الحاجة لامتيازات الجذر على المضيف. هذا يزيل القلق الأمني الرئيسي مع Docker: أن العفريت يعمل كجذر، وهروب الحاوية يعني الوصول كجذر إلى المضيف.

في الوضع بدون صلاحيات الجذر، حتى لو هرب مهاجم من الحاوية، يحصل فقط على امتيازات المستخدم غير المميز الذي يشغل Docker. المقايضة هي أن بعض الميزات (مثل الربط بمنافذ أقل من 1024) تتطلب إعداداً إضافياً.
</details>

## Docker Compose والتنسيق

<details>
<summary><strong>13. ما الفرق بين docker-compose up وdocker-compose run؟</strong></summary>
<br>

- `docker compose up`: يبدأ **جميع** الخدمات المعرّفة في `docker-compose.yml`، ينشئ الشبكات/المجلدات، ويحترم ترتيب `depends_on`. يُستخدم عادة لرفع المكدس بالكامل.
- `docker compose run <خدمة> <أمر>`: يبدأ **خدمة واحدة** بأمر لمرة واحدة. لا يبدأ الخدمات التابعة افتراضياً (استخدم `--service-ports` لتعيين المنافذ، `--rm` للتنظيف). يُستخدم لتشغيل الترحيلات أو الاختبارات أو المهام الإدارية.
</details>

<details>
<summary><strong>14. كيف يعمل depends_on وما هي حدوده؟</strong></summary>
<br>

`depends_on` يتحكم في **ترتيب البدء** — يضمن أن الخدمة A تبدأ قبل الخدمة B. ومع ذلك، ينتظر فقط **بدء** الحاوية، وليس **جاهزية** التطبيق بداخلها.

على سبيل المثال، قد تبدأ حاوية قاعدة البيانات في ثوانٍ، لكن PostgreSQL يحتاج وقتاً إضافياً للتهيئة. ستبدأ حاوية تطبيقك وتفشل فوراً في الاتصال.

الحل: استخدم `depends_on` مع `condition` وفحص صحة:

```yaml
services:
  db:
    image: postgres:16
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 5s
      timeout: 5s
      retries: 5
  app:
    depends_on:
      db:
        condition: service_healthy
```
</details>

<details>
<summary><strong>15. متى تختار Docker Swarm بدلاً من Kubernetes؟</strong></summary>
<br>

**Docker Swarm**: مدمج في Docker، بدون إعداد إضافي. الأفضل للنشر الصغير إلى المتوسط حيث تهم البساطة. يستخدم نفس ملفات Docker Compose. نظام بيئي ومجتمع محدودان مقارنة بـ Kubernetes. مناسب للفرق التي ليس لديها مهندسو منصات مخصصون.

**Kubernetes**: المعيار الصناعي لتنسيق الحاويات على نطاق واسع. يدعم التوسع التلقائي والتحديثات التدريجية وشبكة الخدمات وتعريفات الموارد المخصصة ونظام بيئي ضخم (Helm، Istio، ArgoCD). تعقيد ومنحنى تعلم أعلى. مطلوب للنشر واسع النطاق ومتعدد الفرق ومتعدد السحابة.

قاعدة عامة: إذا كان لديك أقل من 20 خدمة وفريق صغير، فإن Swarm كافٍ. بعد ذلك، يستحق Kubernetes الاستثمار.
</details>

## الإنتاج واستكشاف الأخطاء

<details>
<summary><strong>16. كيف تقلل حجم صورة Docker؟</strong></summary>
<br>

1. **استخدم البناء متعدد المراحل** — أبقِ أدوات البناء خارج الصورة النهائية.
2. **استخدم صور أساسية بحد أدنى** — `alpine` (~5 ميغابايت) بدلاً من `ubuntu` (~75 ميغابايت).
3. **ادمج أوامر RUN** — كل `RUN` ينشئ طبقة. سلسل الأوامر بـ `&&` ونظّف في نفس الطبقة.
4. **استخدم .dockerignore** — استبعد `node_modules` و`.git` وملفات الاختبار والتوثيق من سياق البناء.
5. **رتّب الطبقات حسب تكرار التغيير** — ضع الطبقات نادرة التغيير (التبعيات) قبل الطبقات كثيرة التغيير (الشفرة المصدرية) لتعظيم إصابات الذاكرة المؤقتة.
</details>

<details>
<summary><strong>17. حاوية تستمر في إعادة التشغيل. كيف تصلح الخلل؟</strong></summary>
<br>

نهج خطوة بخطوة:
1. `docker ps -a` — تحقق من رمز الخروج. رمز 137 = قُتل بسبب نفاد الذاكرة. رمز 1 = خطأ في التطبيق.
2. `docker logs <container>` — اقرأ سجلات التطبيق بحثاً عن تتبعات المكدس أو رسائل الخطأ.
3. `docker inspect <container>` — تحقق من `State.OOMKilled` وحدود الموارد ومتغيرات البيئة.
4. `docker run -it --entrypoint /bin/sh <image>` — ابدأ غلافاً تفاعلياً لتصحيح البيئة يدوياً.
5. `docker stats` — تحقق مما إذا كانت الحاوية تصل لحدود الذاكرة أو المعالج.
6. تحقق من `docker events` — ابحث عن إشارات القتل أو أحداث نفاد الذاكرة من العفريت.
</details>

<details>
<summary><strong>18. ما الفرق بين docker stop وdocker kill؟</strong></summary>
<br>

- `docker stop` يرسل **SIGTERM** إلى العملية الرئيسية (PID 1) وينتظر فترة سماح (افتراضياً 10 ثوانٍ). إذا لم تنتهِ العملية، يرسل Docker إشارة SIGKILL. هذا يسمح للتطبيق بإجراء إيقاف أنيق (إغلاق الاتصالات، تفريغ المخازن المؤقتة، حفظ الحالة).
- `docker kill` يرسل **SIGKILL** فوراً. تنتهي العملية بدون أي فرصة للتنظيف. استخدمه فقط عندما لا تستجيب الحاوية.

أفضل ممارسة: استخدم دائماً `docker stop` في الإنتاج. تأكد من أن تطبيقك يعالج SIGTERM بشكل صحيح.
</details>

<details>
<summary><strong>19. كيف تتعامل مع الأسرار في Docker؟</strong></summary>
<br>

**لا تضمّن أبداً** الأسرار في الصور (ENV في Dockerfile، COPY لملفات .env). تبقى في طبقات الصورة وتكون مرئية بـ `docker history`.

مناهج حسب مستوى النضج:
- **أساسي**: مرّر الأسرار عبر `--env-file` أثناء التشغيل (الملف غير مضمّن في الصورة).
- **أفضل**: استخدم أسرار Docker Swarm أو Kubernetes secrets (تُثبّت كملفات، ليس كمتغيرات بيئة).
- **الأمثل**: استخدم مدير أسرار خارجي (HashiCorp Vault، AWS Secrets Manager، Azure Key Vault) وحقن الأسرار أثناء التشغيل عبر sidecar أو init container.
</details>

<details>
<summary><strong>20. ما هو فحص صحة Docker ولماذا هو حاسم؟</strong></summary>
<br>

فحص الصحة هو أمر ينفذه Docker دورياً داخل الحاوية للتحقق من أن التطبيق يعمل فعلاً — وليس فقط أن العملية تعمل.

```dockerfile
HEALTHCHECK --interval=30s --timeout=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1
```

بدون فحص صحة، يعرف Docker فقط ما إذا كانت العملية حية (PID موجود). مع فحص صحة، يعرف Docker ما إذا كان التطبيق **سليماً** (يستجيب للطلبات). هذا حاسم لـ:
- **موازنات الحمل**: توجيه حركة المرور فقط إلى الحاويات السليمة.
- **المنسقات**: إعادة تشغيل الحاويات غير السليمة تلقائياً.
- **depends_on**: انتظار الجاهزية الفعلية، وليس مجرد بدء العملية.
</details>
