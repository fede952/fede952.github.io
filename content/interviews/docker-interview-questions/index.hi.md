---
title: "Docker इंटरव्यू के शीर्ष 20 प्रश्न और उत्तर (2026 संस्करण)"
description: "कंटेनर, इमेज, नेटवर्किंग, वॉल्यूम, Docker Compose और प्रोडक्शन बेस्ट प्रैक्टिस को कवर करने वाले इन 20 उन्नत Docker प्रश्नों के साथ अपने Senior DevOps इंटरव्यू में सफल हों।"
date: 2026-02-11
tags: ["docker", "interview", "devops", "containers"]
keywords: ["docker इंटरव्यू प्रश्न", "सीनियर devops इंटरव्यू", "कंटेनराइजेशन प्रश्न", "docker इंटरव्यू उत्तर", "docker compose इंटरव्यू", "dockerfile बेस्ट प्रैक्टिस", "कंटेनर ऑर्केस्ट्रेशन इंटरव्यू", "docker नेटवर्किंग प्रश्न", "devops इंजीनियर इंटरव्यू", "docker प्रोडक्शन प्रश्न"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Docker इंटरव्यू के शीर्ष 20 प्रश्न और उत्तर (2026 संस्करण)",
    "description": "कंटेनर, इमेज, नेटवर्किंग और प्रोडक्शन बेस्ट प्रैक्टिस को कवर करने वाले Senior DevOps भूमिकाओं के लिए उन्नत Docker इंटरव्यू प्रश्न।",
    "proficiencyLevel": "Advanced",
    "inLanguage": "hi"
  }
---

## सिस्टम इनिशियलाइज़ेशन

Docker किसी भी DevOps, SRE, या बैकएंड इंजीनियरिंग भूमिका के लिए एक अनिवार्य कौशल बन गया है। सीनियर स्तर के साक्षात्कारकर्ता उम्मीद करते हैं कि आप `docker run` से आगे जाएं — वे देखना चाहते हैं कि आप इमेज लेयरिंग, नेटवर्किंग की आंतरिक संरचना, सुरक्षा सुदृढ़ीकरण और प्रोडक्शन-ग्रेड ऑर्केस्ट्रेशन पैटर्न को समझते हैं। इस गाइड में सीनियर और लीड-स्तरीय इंटरव्यू में सबसे अधिक पूछे जाने वाले 20 प्रश्न हैं, विस्तृत उत्तरों के साथ जो गहराई प्रदर्शित करते हैं।

**इंटरव्यू से पहले कमांड की त्वरित समीक्षा चाहिए?** हमारी [Docker Captain's Log चीटशीट](/cheatsheets/docker-container-commands/) को बुकमार्क करें।

---

## मूल अवधारणाएँ

<details>
<summary><strong>1. कंटेनर और वर्चुअल मशीन में क्या अंतर है?</strong></summary>
<br>

एक **वर्चुअल मशीन** हाइपरवाइज़र के ऊपर एक पूर्ण गेस्ट OS चलाती है, जिसमें अपना कर्नेल, ड्राइवर और सिस्टम लाइब्रेरी शामिल हैं। प्रत्येक VM पूरी तरह से पृथक होती है लेकिन महत्वपूर्ण संसाधन खपत करती है (GBs RAM, बूट होने में मिनट)।

एक **कंटेनर** होस्ट OS कर्नेल को साझा करता है और Linux नेमस्पेस और cgroups का उपयोग करके प्रक्रियाओं को पृथक करता है। यह केवल एप्लिकेशन और उसकी निर्भरताओं को पैकेज करता है — कोई अलग कर्नेल नहीं। यह कंटेनर को हल्का (MBs), तेज़ी से शुरू होने वाला (मिलीसेकंड) और अत्यधिक पोर्टेबल बनाता है।

मुख्य अंतर: VMs **हार्डवेयर** को वर्चुअलाइज़ करती हैं, कंटेनर **ऑपरेटिंग सिस्टम** को वर्चुअलाइज़ करते हैं।
</details>

<details>
<summary><strong>2. Docker इमेज लेयर क्या हैं और वे कैसे काम करती हैं?</strong></summary>
<br>

एक Docker इमेज **रीड-ओनली लेयर्स** की श्रृंखला से बनाई जाती है। Dockerfile में प्रत्येक निर्देश (`FROM`, `RUN`, `COPY`, आदि) एक नई लेयर बनाता है। लेयर्स यूनियन फाइलसिस्टम (जैसे OverlayFS) का उपयोग करके एक-दूसरे के ऊपर रखी जाती हैं।

जब एक कंटेनर चलता है, Docker शीर्ष पर एक पतली **लिखने योग्य लेयर** (कंटेनर लेयर) जोड़ता है। रनटाइम पर किए गए परिवर्तन केवल इस लिखने योग्य लेयर को प्रभावित करते हैं — अंतर्निहित इमेज लेयर्स अपरिवर्तित रहती हैं।

यह आर्किटेक्चर निम्नलिखित को सक्षम करता है:
- **कैशिंग**: यदि कोई लेयर नहीं बदली है, तो Docker बिल्ड के दौरान उसे कैश से पुनः उपयोग करता है।
- **साझाकरण**: एक ही इमेज से कई कंटेनर रीड-ओनली लेयर्स साझा करते हैं, जिससे डिस्क स्पेस बचता है।
- **दक्षता**: केवल संशोधित लेयर्स को रजिस्ट्री से पुल या पुश करने की आवश्यकता होती है।
</details>

<details>
<summary><strong>3. Dockerfile में CMD और ENTRYPOINT में क्या अंतर है?</strong></summary>
<br>

दोनों परिभाषित करते हैं कि कंटेनर शुरू होने पर क्या चलता है, लेकिन वे अलग तरह से व्यवहार करते हैं:

- **CMD** डिफ़ॉल्ट आर्गुमेंट प्रदान करता है जो रनटाइम पर पूरी तरह से ओवरराइड किए जा सकते हैं। यदि आप `docker run myimage /bin/bash` चलाते हैं, तो CMD बदल जाता है।
- **ENTRYPOINT** मुख्य एक्ज़ीक्यूटेबल को परिभाषित करता है जो हमेशा चलता है। रनटाइम आर्गुमेंट इसमें जोड़े जाते हैं, बदले नहीं जाते।

सर्वोत्तम प्रथा: मुख्य प्रक्रिया के लिए `ENTRYPOINT` और डिफ़ॉल्ट आर्गुमेंट के लिए `CMD` का उपयोग करें:

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD ["--port", "8080"]
```

`docker run myimage --port 3000` चलाने पर `python app.py --port 3000` निष्पादित होगा।
</details>

<details>
<summary><strong>4. मल्टी-स्टेज बिल्ड क्या है और यह क्यों महत्वपूर्ण है?</strong></summary>
<br>

मल्टी-स्टेज बिल्ड एक ही Dockerfile में कई `FROM` स्टेटमेंट का उपयोग करता है। प्रत्येक `FROM` एक नया बिल्ड स्टेज शुरू करता है, और आप एक स्टेज से दूसरे में चयनात्मक रूप से आर्टिफैक्ट कॉपी कर सकते हैं।

```dockerfile
# Stage 1: Build
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# Stage 2: Run (minimal image)
FROM alpine:3.18
COPY --from=builder /app/myapp /usr/local/bin/
CMD ["myapp"]
```

यह केवल संकलित बाइनरी वाली एक अंतिम इमेज तैयार करता है — कोई बिल्ड टूल नहीं, कोई सोर्स कोड नहीं, कोई मध्यवर्ती फाइलें नहीं। परिणाम एक नाटकीय रूप से छोटी इमेज (अक्सर 10-100 गुना छोटी) है जिसकी हमले की सतह कम होती है।
</details>

<details>
<summary><strong>5. Dockerfile में COPY और ADD में क्या अंतर है?</strong></summary>
<br>

दोनों बिल्ड संदर्भ से इमेज में फाइलें कॉपी करते हैं, लेकिन `ADD` में अतिरिक्त सुविधाएँ हैं:
- `ADD` स्थानीय `.tar` आर्काइव को स्वचालित रूप से निकाल सकता है।
- `ADD` URLs से फाइलें डाउनलोड कर सकता है।

हालांकि, Docker सर्वोत्तम प्रथाएँ लगभग सभी मामलों में `COPY` का उपयोग करने की सलाह देती हैं क्योंकि यह स्पष्ट और अनुमानित है। `ADD` का उपयोग केवल तब करें जब आपको विशेष रूप से tar निष्कर्षण की आवश्यकता हो। फाइलें डाउनलोड करने के लिए कभी भी `ADD` का उपयोग न करें — इसके बजाय `RUN curl` या `RUN wget` का उपयोग करें, ताकि डाउनलोड लेयर को सही ढंग से कैश किया जा सके।
</details>

## नेटवर्किंग

<details>
<summary><strong>6. Docker के नेटवर्किंग मोड (bridge, host, none, overlay) समझाएं।</strong></summary>
<br>

- **Bridge** (डिफ़ॉल्ट): होस्ट पर एक निजी आंतरिक नेटवर्क बनाता है। एक ही ब्रिज पर कंटेनर IP या कंटेनर नाम से संवाद कर सकते हैं। बाहरी ट्रैफ़िक के लिए पोर्ट मैपिंग (`-p`) आवश्यक है।
- **Host**: नेटवर्क आइसोलेशन हटा देता है। कंटेनर सीधे होस्ट के नेटवर्क स्टैक को साझा करता है। पोर्ट मैपिंग की ज़रूरत नहीं, लेकिन आइसोलेशन भी नहीं। प्रदर्शन-महत्वपूर्ण अनुप्रयोगों के लिए उपयोगी।
- **None**: कोई नेटवर्किंग नहीं। कंटेनर में केवल लूपबैक इंटरफ़ेस होता है। बैच जॉब्स या सुरक्षा-संवेदनशील वर्कलोड के लिए उपयोग किया जाता है।
- **Overlay**: कई Docker होस्ट्स में फैला होता है (Swarm/Kubernetes में उपयोग)। विभिन्न मशीनों पर कंटेनर VXLAN टनलिंग का उपयोग करके एक ही नेटवर्क पर होने जैसे संवाद कर सकते हैं।
</details>

<details>
<summary><strong>7. कंटेनर-से-कंटेनर संचार कैसे काम करता है?</strong></summary>
<br>

उपयोगकर्ता-परिभाषित ब्रिज नेटवर्क पर, कंटेनर Docker के अंतर्निहित DNS रिज़ॉल्वर के माध्यम से **कंटेनर नाम से** एक-दूसरे तक पहुँच सकते हैं। DNS सर्वर प्रत्येक कंटेनर के अंदर `127.0.0.11` पर चलता है।

डिफ़ॉल्ट ब्रिज नेटवर्क पर, DNS रिज़ॉल्यूशन **उपलब्ध नहीं** है — कंटेनर केवल IP पते से संवाद कर सकते हैं, जो अविश्वसनीय है क्योंकि IPs गतिशील रूप से असाइन किए जाते हैं।

सर्वोत्तम प्रथा: हमेशा एक कस्टम ब्रिज नेटवर्क (`docker network create mynet`) बनाएं और कंटेनरों को इससे जोड़ें। अंतर-कंटेनर संचार के लिए कभी भी डिफ़ॉल्ट ब्रिज पर निर्भर न रहें।
</details>

<details>
<summary><strong>8. EXPOSE और पोर्ट प्रकाशित करने में क्या अंतर है?</strong></summary>
<br>

Dockerfile में `EXPOSE` पूरी तरह से **प्रलेखन** है — यह Dockerfile पढ़ने वाले किसी भी व्यक्ति को बताता है कि एप्लिकेशन एक विशिष्ट पोर्ट पर सुन रहा है। यह वास्तव में पोर्ट खोलता या मैप नहीं करता।

पोर्ट प्रकाशित करना (`-p 8080:80`) वास्तव में एक नेटवर्क नियम बनाता है जो होस्ट पोर्ट को कंटेनर पोर्ट से मैप करता है, सेवा को कंटेनर के बाहर से सुलभ बनाता है।

आप ऐसे पोर्ट प्रकाशित कर सकते हैं जो `EXPOSE` निर्देश में नहीं हैं, और `EXPOSE` अकेले `-p` के बिना कुछ नहीं करता।
</details>

## वॉल्यूम और स्टोरेज

<details>
<summary><strong>9. Docker माउंट के तीन प्रकार क्या हैं?</strong></summary>
<br>

1. **वॉल्यूम** (`docker volume create`): Docker द्वारा प्रबंधित, `/var/lib/docker/volumes/` में संग्रहीत। स्थायी डेटा (डेटाबेस) के लिए सर्वोत्तम। कंटेनर हटाने के बाद भी बना रहता है। होस्ट्स के बीच पोर्टेबल।
2. **बाइंड माउंट** (`-v /host/path:/container/path`): एक विशिष्ट होस्ट डायरेक्टरी को कंटेनर में मैप करता है। होस्ट पथ मौजूद होना चाहिए। विकास (लाइव कोड रीलोडिंग) के लिए सर्वोत्तम। पोर्टेबल नहीं।
3. **tmpfs माउंट** (`--tmpfs /tmp`): केवल होस्ट की मेमोरी में संग्रहीत। कभी डिस्क पर नहीं लिखा जाता। संवेदनशील डेटा के लिए सर्वोत्तम जो स्थायी नहीं होना चाहिए (सीक्रेट्स, सेशन टोकन)।
</details>

<details>
<summary><strong>10. डेटाबेस कंटेनर के डेटा को कैसे स्थायी बनाएं?</strong></summary>
<br>

डेटाबेस के डेटा डायरेक्टरी में माउंट किए गए **नामित वॉल्यूम** का उपयोग करें:

```bash
docker volume create pgdata
docker run -d -v pgdata:/var/lib/postgresql/data postgres:16
```

डेटा कंटेनर के पुनरारंभ और हटाने के बाद भी बना रहता है। डेटाबेस संस्करण अपग्रेड करते समय, पुराने कंटेनर को रोकें, उसी वॉल्यूम के साथ नया शुरू करें, और नए संस्करण को डेटा माइग्रेशन संभालने दें।

प्रोडक्शन डेटाबेस के लिए कभी बाइंड माउंट का उपयोग न करें — वॉल्यूम में बेहतर I/O प्रदर्शन होता है और Docker के स्टोरेज ड्राइवर द्वारा प्रबंधित होते हैं।
</details>

## सुरक्षा

<details>
<summary><strong>11. प्रोडक्शन में Docker कंटेनर को कैसे सुरक्षित करें?</strong></summary>
<br>

प्रमुख सुदृढ़ीकरण प्रथाएँ:
- **नॉन-रूट के रूप में चलाएं**: Dockerfile में `USER` निर्देश का उपयोग करें। एप्लिकेशन प्रक्रियाओं को कभी रूट के रूप में न चलाएं।
- **न्यूनतम बेस इमेज का उपयोग करें**: `ubuntu` के बजाय `alpine`, `distroless`, या `scratch` का उपयोग करें।
- **क्षमताएँ हटाएं**: `--cap-drop ALL --cap-add <केवल-आवश्यक>` का उपयोग करें।
- **रीड-ओनली फाइलसिस्टम**: `--read-only` का उपयोग करें और केवल विशिष्ट लिखने योग्य पथ माउंट करें।
- **कोई नए विशेषाधिकार नहीं**: `--security-opt=no-new-privileges` का उपयोग करें।
- **इमेज स्कैन करें**: बेस इमेज और निर्भरताओं में कमजोरियों का पता लगाने के लिए `docker scout`, Trivy, या Snyk का उपयोग करें।
- **इमेज पर हस्ताक्षर करें**: इमेज की प्रामाणिकता सत्यापित करने के लिए Docker Content Trust (`DOCKER_CONTENT_TRUST=1`) का उपयोग करें।
- **संसाधन सीमित करें**: संसाधन समाप्ति को रोकने के लिए `--memory`, `--cpus` का उपयोग करें।
</details>

<details>
<summary><strong>12. Docker रूटलेस मोड क्या है?</strong></summary>
<br>

Docker रूटलेस मोड Docker डेमन और कंटेनरों को पूरी तरह से एक यूज़र नेमस्पेस के अंदर चलाता है, होस्ट पर रूट विशेषाधिकारों की आवश्यकता के बिना। यह Docker के साथ मुख्य सुरक्षा चिंता को समाप्त करता है: कि डेमन रूट के रूप में चलता है, और कंटेनर से बचना होस्ट पर रूट एक्सेस का अर्थ है।

रूटलेस मोड में, भले ही कोई हमलावर कंटेनर से बच निकले, उसे केवल Docker चलाने वाले अनविशेषाधिकृत उपयोगकर्ता के विशेषाधिकार मिलते हैं। समझौता यह है कि कुछ सुविधाओं (जैसे 1024 से नीचे के पोर्ट से बाइंडिंग) के लिए अतिरिक्त कॉन्फ़िगरेशन की आवश्यकता होती है।
</details>

## Docker Compose और ऑर्केस्ट्रेशन

<details>
<summary><strong>13. docker-compose up और docker-compose run में क्या अंतर है?</strong></summary>
<br>

- `docker compose up`: `docker-compose.yml` में परिभाषित **सभी** सेवाओं को शुरू करता है, नेटवर्क/वॉल्यूम बनाता है, और `depends_on` क्रम का पालन करता है। आमतौर पर पूरे स्टैक को शुरू करने के लिए उपयोग किया जाता है।
- `docker compose run <सेवा> <कमांड>`: एक बार के कमांड के साथ **एकल** सेवा शुरू करता है। डिफ़ॉल्ट रूप से निर्भर सेवाओं को शुरू नहीं करता (पोर्ट मैप करने के लिए `--service-ports`, सफाई के लिए `--rm` का उपयोग करें)। माइग्रेशन, टेस्ट या एडमिन कार्यों को चलाने के लिए उपयोग किया जाता है।
</details>

<details>
<summary><strong>14. depends_on कैसे काम करता है और इसकी सीमाएँ क्या हैं?</strong></summary>
<br>

`depends_on` **स्टार्टअप क्रम** को नियंत्रित करता है — यह सुनिश्चित करता है कि सेवा A सेवा B से पहले शुरू हो। हालांकि, यह केवल कंटेनर के **शुरू** होने का इंतज़ार करता है, अंदर के एप्लिकेशन के **तैयार** होने का नहीं।

उदाहरण के लिए, एक डेटाबेस कंटेनर सेकंडों में शुरू हो सकता है, लेकिन PostgreSQL को आरंभीकरण के लिए अतिरिक्त समय चाहिए। आपका ऐप कंटेनर शुरू होगा और तुरंत कनेक्ट करने में विफल हो जाएगा।

समाधान: `depends_on` को `condition` और हेल्थ चेक के साथ उपयोग करें:

```yaml
services:
  db:
    image: postgres:16
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 5s
      timeout: 5s
      retries: 5
  app:
    depends_on:
      db:
        condition: service_healthy
```
</details>

<details>
<summary><strong>15. Docker Swarm बनाम Kubernetes कब चुनेंगे?</strong></summary>
<br>

**Docker Swarm**: Docker में अंतर्निहित, शून्य अतिरिक्त सेटअप। छोटे से मध्यम डिप्लॉयमेंट के लिए सर्वोत्तम जहाँ सरलता मायने रखती है। वही Docker Compose फाइलें उपयोग करता है। Kubernetes की तुलना में सीमित इकोसिस्टम और समुदाय। उन टीमों के लिए उपयुक्त जिनके पास समर्पित प्लेटफ़ॉर्म इंजीनियर नहीं हैं।

**Kubernetes**: बड़े पैमाने पर कंटेनर ऑर्केस्ट्रेशन के लिए उद्योग मानक। ऑटो-स्केलिंग, रोलिंग अपडेट, सर्विस मेश, कस्टम रिसोर्स डेफिनिशन, और एक विशाल इकोसिस्टम (Helm, Istio, ArgoCD) का समर्थन करता है। उच्च जटिलता और सीखने की अवस्था। बड़े पैमाने, बहु-टीम, बहु-क्लाउड डिप्लॉयमेंट के लिए आवश्यक।

अंगूठे का नियम: यदि आपके पास 20 से कम सेवाएँ और एक छोटी टीम है, तो Swarm पर्याप्त है। उससे आगे, Kubernetes निवेश के लायक है।
</details>

## प्रोडक्शन और समस्या निवारण

<details>
<summary><strong>16. Docker इमेज का आकार कैसे कम करें?</strong></summary>
<br>

1. **मल्टी-स्टेज बिल्ड का उपयोग करें** — बिल्ड टूल्स को अंतिम इमेज से बाहर रखें।
2. **न्यूनतम बेस इमेज का उपयोग करें** — `ubuntu` (~75MB) के बजाय `alpine` (~5MB)।
3. **RUN कमांड को संयोजित करें** — प्रत्येक `RUN` एक लेयर बनाता है। `&&` के साथ कमांड को जोड़ें और उसी लेयर में सफाई करें।
4. **.dockerignore का उपयोग करें** — बिल्ड संदर्भ से `node_modules`, `.git`, टेस्ट फाइलें, डॉक्स को बाहर रखें।
5. **परिवर्तन आवृत्ति के अनुसार लेयर्स का क्रम निर्धारित करें** — कैश हिट को अधिकतम करने के लिए कम बदलने वाली लेयर्स (निर्भरताएँ) को अक्सर बदलने वाली लेयर्स (सोर्स कोड) से पहले रखें।
</details>

<details>
<summary><strong>17. एक कंटेनर बार-बार रीस्टार्ट हो रहा है। आप इसे कैसे डीबग करेंगे?</strong></summary>
<br>

चरण-दर-चरण दृष्टिकोण:
1. `docker ps -a` — एग्ज़िट कोड जांचें। एग्ज़िट कोड 137 = OOM किल्ड। एग्ज़िट कोड 1 = एप्लिकेशन त्रुटि।
2. `docker logs <container>` — स्टैक ट्रेस या त्रुटि संदेशों के लिए एप्लिकेशन लॉग पढ़ें।
3. `docker inspect <container>` — `State.OOMKilled`, संसाधन सीमाएँ, और पर्यावरण चर जांचें।
4. `docker run -it --entrypoint /bin/sh <image>` — पर्यावरण को मैन्युअल रूप से डीबग करने के लिए इंटरैक्टिव शेल शुरू करें।
5. `docker stats` — जांचें कि कंटेनर मेमोरी या CPU सीमाओं तक पहुँच रहा है या नहीं।
6. `docker events` जांचें — डेमन से किल सिग्नल या OOM इवेंट खोजें।
</details>

<details>
<summary><strong>18. docker stop और docker kill में क्या अंतर है?</strong></summary>
<br>

- `docker stop` मुख्य प्रक्रिया (PID 1) को **SIGTERM** भेजता है और एक अनुग्रह अवधि (डिफ़ॉल्ट 10 सेकंड) का इंतज़ार करता है। यदि प्रक्रिया बंद नहीं होती, तो Docker SIGKILL भेजता है। यह एप्लिकेशन को ग्रेसफुल शटडाउन (कनेक्शन बंद करना, बफ़र फ्लश करना, स्थिति सहेजना) करने की अनुमति देता है।
- `docker kill` तुरंत **SIGKILL** भेजता है। प्रक्रिया बिना किसी सफाई के अवसर के समाप्त हो जाती है। केवल तब उपयोग करें जब कंटेनर प्रतिक्रिया न दे।

सर्वोत्तम प्रथा: प्रोडक्शन में हमेशा `docker stop` का उपयोग करें। सुनिश्चित करें कि आपका एप्लिकेशन SIGTERM को उचित रूप से संभालता है।
</details>

<details>
<summary><strong>19. Docker में सीक्रेट्स कैसे संभालें?</strong></summary>
<br>

सीक्रेट्स को इमेज में **कभी** न बेक करें (Dockerfile में ENV, .env फाइलों का COPY)। वे इमेज लेयर्स में बने रहते हैं और `docker history` से दिखाई देते हैं।

परिपक्वता स्तर के अनुसार दृष्टिकोण:
- **बुनियादी**: रनटाइम पर `--env-file` के माध्यम से सीक्रेट्स पास करें (फाइल इमेज में शामिल नहीं)।
- **बेहतर**: Docker Swarm सीक्रेट्स या Kubernetes सीक्रेट्स का उपयोग करें (पर्यावरण चर के रूप में नहीं, फाइलों के रूप में माउंट)।
- **सर्वोत्तम**: बाहरी सीक्रेट्स मैनेजर (HashiCorp Vault, AWS Secrets Manager, Azure Key Vault) का उपयोग करें और sidecar या init container के माध्यम से रनटाइम पर सीक्रेट्स इंजेक्ट करें।
</details>

<details>
<summary><strong>20. Docker हेल्थ चेक क्या है और यह क्यों महत्वपूर्ण है?</strong></summary>
<br>

हेल्थ चेक एक कमांड है जो Docker कंटेनर के अंदर समय-समय पर चलाता है ताकि सत्यापित किया जा सके कि एप्लिकेशन वास्तव में काम कर रहा है — न कि केवल प्रक्रिया चल रही है।

```dockerfile
HEALTHCHECK --interval=30s --timeout=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1
```

हेल्थ चेक के बिना, Docker केवल जानता है कि प्रक्रिया जीवित है (PID मौजूद है)। हेल्थ चेक के साथ, Docker जानता है कि एप्लिकेशन **स्वस्थ** है (अनुरोधों का जवाब दे रहा है)। यह निम्नलिखित के लिए महत्वपूर्ण है:
- **लोड बैलेंसर**: केवल स्वस्थ कंटेनरों को ट्रैफ़िक भेजना।
- **ऑर्केस्ट्रेटर**: अस्वस्थ कंटेनरों को स्वचालित रूप से पुनरारंभ करना।
- **depends_on**: केवल प्रक्रिया शुरू होने के बजाय वास्तविक तैयारी का इंतज़ार करना।
</details>
