---
title: "Топ 20 вопросов и ответов на собеседовании по Docker (Издание 2026)"
description: "Успешно пройдите собеседование на позицию Senior DevOps с этими 20 продвинутыми вопросами по Docker, охватывающими контейнеры, образы, сети, тома, Docker Compose и лучшие практики для продакшена."
date: 2026-02-11
tags: ["docker", "interview", "devops", "containers"]
keywords: ["вопросы собеседование docker", "собеседование senior devops", "вопросы контейнеризация", "ответы собеседование docker", "собеседование docker compose", "лучшие практики dockerfile", "собеседование оркестрация контейнеров", "вопросы сети docker", "собеседование инженер devops", "вопросы docker продакшен"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Топ 20 вопросов и ответов на собеседовании по Docker (Издание 2026)",
    "description": "Продвинутые вопросы на собеседовании по Docker для Senior DevOps ролей, охватывающие контейнеры, образы, сети и лучшие практики для продакшена.",
    "proficiencyLevel": "Advanced",
    "inLanguage": "ru"
  }
---

## Инициализация системы

Docker стал обязательным навыком для любой роли DevOps, SRE или бэкенд-инженерии. Интервьюеры на уровне Senior ожидают, что вы выйдете за рамки `docker run` — они хотят видеть, что вы понимаете слоистость образов, внутреннее устройство сетей, усиление безопасности и паттерны оркестрации для продакшена. Это руководство содержит 20 вопросов, наиболее часто задаваемых на собеседованиях уровня Senior и Lead, с подробными ответами, демонстрирующими глубину знаний.

**Нужно быстро освежить команды перед собеседованием?** Сохраните в закладки наш [Шпаргалка Docker Captain's Log](/cheatsheets/docker-container-commands/).

---

## Основные концепции

<details>
<summary><strong>1. В чём разница между контейнером и виртуальной машиной?</strong></summary>
<br>

**Виртуальная машина** запускает полноценную гостевую ОС поверх гипервизора, включая собственное ядро, драйверы и системные библиотеки. Каждая ВМ полностью изолирована, но потребляет значительные ресурсы (ГБ оперативной памяти, минуты на загрузку).

**Контейнер** разделяет ядро ОС хоста и изолирует процессы с помощью пространств имён Linux и cgroups. Он содержит только приложение и его зависимости — без отдельного ядра. Это делает контейнеры лёгкими (МБ), быстрыми для запуска (миллисекунды) и высокопортативными.

Ключевое отличие: ВМ виртуализируют **оборудование**, контейнеры виртуализируют **операционную систему**.
</details>

<details>
<summary><strong>2. Что такое слои образов Docker и как они работают?</strong></summary>
<br>

Образ Docker строится из серии **слоёв только для чтения**. Каждая инструкция в Dockerfile (`FROM`, `RUN`, `COPY` и т.д.) создаёт новый слой. Слои накладываются друг на друга с помощью объединённой файловой системы (например, OverlayFS).

При запуске контейнера Docker добавляет тонкий **записываемый слой** поверх (слой контейнера). Изменения, сделанные во время выполнения, затрагивают только этот записываемый слой — нижележащие слои образа остаются неизменными.

Эта архитектура обеспечивает:
- **Кэширование**: Если слой не изменился, Docker повторно использует его из кэша при сборке.
- **Совместное использование**: Несколько контейнеров из одного образа разделяют слои только для чтения, экономя дисковое пространство.
- **Эффективность**: Только изменённые слои нужно скачивать или отправлять в реестры.
</details>

<details>
<summary><strong>3. В чём разница между CMD и ENTRYPOINT в Dockerfile?</strong></summary>
<br>

Оба определяют, что запускается при старте контейнера, но ведут себя по-разному:

- **CMD** предоставляет аргументы по умолчанию, которые могут быть полностью переопределены во время выполнения. Если вы выполните `docker run myimage /bin/bash`, CMD будет заменён.
- **ENTRYPOINT** определяет основной исполняемый файл, который всегда запускается. Аргументы времени выполнения добавляются к нему, а не заменяют его.

Лучшая практика: Используйте `ENTRYPOINT` для основного процесса и `CMD` для аргументов по умолчанию:

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD ["--port", "8080"]
```

Выполнение `docker run myimage --port 3000` запустит `python app.py --port 3000`.
</details>

<details>
<summary><strong>4. Что такое многоэтапная сборка и почему она важна?</strong></summary>
<br>

Многоэтапная сборка использует несколько инструкций `FROM` в одном Dockerfile. Каждый `FROM` начинает новый этап сборки, и вы можете выборочно копировать артефакты из одного этапа в другой.

```dockerfile
# Stage 1: Build
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp

# Stage 2: Run (minimal image)
FROM alpine:3.18
COPY --from=builder /app/myapp /usr/local/bin/
CMD ["myapp"]
```

Это создаёт финальный образ, содержащий только скомпилированный бинарный файл — без инструментов сборки, без исходного кода, без промежуточных файлов. Результат — значительно меньший образ (часто в 10-100 раз меньше) с уменьшенной поверхностью атаки.
</details>

<details>
<summary><strong>5. В чём разница между COPY и ADD в Dockerfile?</strong></summary>
<br>

Оба копируют файлы из контекста сборки в образ, но `ADD` имеет дополнительные функции:
- `ADD` может автоматически распаковывать локальные архивы `.tar`.
- `ADD` может скачивать файлы по URL.

Однако лучшие практики Docker рекомендуют использовать `COPY` почти во всех случаях, потому что он явный и предсказуемый. Используйте `ADD` только когда вам конкретно нужна распаковка tar. Никогда не используйте `ADD` для скачивания файлов — используйте `RUN curl` или `RUN wget` вместо этого, чтобы слой загрузки мог быть правильно кэширован.
</details>

## Сети

<details>
<summary><strong>6. Объясните сетевые режимы Docker (bridge, host, none, overlay).</strong></summary>
<br>

- **Bridge** (по умолчанию): Создаёт частную внутреннюю сеть на хосте. Контейнеры в одном bridge могут общаться по IP или имени контейнера. Трафик наружу требует маппинга портов (`-p`).
- **Host**: Убирает сетевую изоляцию. Контейнер напрямую разделяет сетевой стек хоста. Маппинг портов не нужен, но и изоляции нет. Полезен для приложений с критичными требованиями к производительности.
- **None**: Нет сети вообще. У контейнера только loopback-интерфейс. Используется для пакетных заданий или рабочих нагрузок, чувствительных к безопасности.
- **Overlay**: Охватывает несколько хостов Docker (используется в Swarm/Kubernetes). Контейнеры на разных машинах могут общаться, как будто находятся в одной сети, используя VXLAN-туннелирование.
</details>

<details>
<summary><strong>7. Как работает межконтейнерная коммуникация?</strong></summary>
<br>

В пользовательской bridge-сети контейнеры могут достигать друг друга **по имени контейнера** через встроенный DNS-резолвер Docker. DNS-сервер работает по адресу `127.0.0.11` внутри каждого контейнера.

В стандартной bridge-сети DNS-разрешение **недоступно** — контейнеры могут общаться только по IP-адресу, что ненадёжно, так как IP назначаются динамически.

Лучшая практика: Всегда создавайте пользовательскую bridge-сеть (`docker network create mynet`) и подключайте к ней контейнеры. Никогда не полагайтесь на стандартный bridge для межконтейнерной коммуникации.
</details>

<details>
<summary><strong>8. В чём разница между EXPOSE и публикацией порта?</strong></summary>
<br>

`EXPOSE` в Dockerfile — это чистая **документация** — он сообщает всем, кто читает Dockerfile, что приложение слушает на определённом порту. Он НЕ открывает и не маппит порт на самом деле.

Публикация порта (`-p 8080:80`) фактически создаёт сетевое правило, которое маппит порт хоста на порт контейнера, делая сервис доступным извне контейнера.

Вы можете публиковать порты, которых нет в директиве `EXPOSE`, и `EXPOSE` сам по себе ничего не делает без `-p`.
</details>

## Тома и хранилище

<details>
<summary><strong>9. Какие три типа монтирования существуют в Docker?</strong></summary>
<br>

1. **Тома** (`docker volume create`): Управляются Docker, хранятся в `/var/lib/docker/volumes/`. Лучше всего для постоянных данных (баз данных). Переживают удаление контейнера. Портативны между хостами.
2. **Bind mounts** (`-v /host/path:/container/path`): Маппят конкретную директорию хоста в контейнер. Путь на хосте должен существовать. Лучше всего для разработки (живая перезагрузка кода). Не портативны.
3. **tmpfs mounts** (`--tmpfs /tmp`): Хранятся только в памяти хоста. Никогда не записываются на диск. Лучше всего для чувствительных данных, которые не должны сохраняться (секреты, токены сессий).
</details>

<details>
<summary><strong>10. Как сохранить данные контейнера базы данных?</strong></summary>
<br>

Используйте **именованный том**, смонтированный в директорию данных базы данных:

```bash
docker volume create pgdata
docker run -d -v pgdata:/var/lib/postgresql/data postgres:16
```

Данные переживают перезапуски и удаления контейнера. При обновлении версии базы данных остановите старый контейнер, запустите новый с тем же томом и позвольте новой версии выполнить миграцию данных.

Никогда не используйте bind mounts для продакшен-баз данных — тома имеют лучшую производительность ввода-вывода и управляются драйвером хранилища Docker.
</details>

## Безопасность

<details>
<summary><strong>11. Как обезопасить контейнер Docker в продакшене?</strong></summary>
<br>

Ключевые практики усиления безопасности:
- **Запуск от имени не-root**: Используйте директиву `USER` в Dockerfile. Никогда не запускайте процессы приложения от имени root.
- **Использование минимальных базовых образов**: `alpine`, `distroless` или `scratch` вместо `ubuntu`.
- **Удаление capabilities**: Используйте `--cap-drop ALL --cap-add <только-нужные>`.
- **Файловая система только для чтения**: Используйте `--read-only` и монтируйте только определённые записываемые пути.
- **Без новых привилегий**: Используйте `--security-opt=no-new-privileges`.
- **Сканирование образов**: Используйте `docker scout`, Trivy или Snyk для обнаружения уязвимостей в базовых образах и зависимостях.
- **Подпись образов**: Используйте Docker Content Trust (`DOCKER_CONTENT_TRUST=1`) для проверки подлинности образов.
- **Ограничение ресурсов**: Используйте `--memory`, `--cpus` для предотвращения исчерпания ресурсов.
</details>

<details>
<summary><strong>12. Что такое rootless-режим Docker?</strong></summary>
<br>

Rootless-режим Docker запускает демон Docker и контейнеры полностью в пользовательском пространстве имён, без необходимости привилегий root на хосте. Это устраняет главную проблему безопасности Docker: демон работает от имени root, и побег из контейнера означает root-доступ к хосту.

В rootless-режиме, даже если злоумышленник сбежит из контейнера, он получит только привилегии непривилегированного пользователя, запускающего Docker. Компромисс в том, что некоторые функции (такие как привязка к портам ниже 1024) требуют дополнительной настройки.
</details>

## Docker Compose и оркестрация

<details>
<summary><strong>13. В чём разница между docker-compose up и docker-compose run?</strong></summary>
<br>

- `docker compose up`: Запускает **все** сервисы, определённые в `docker-compose.yml`, создаёт сети/тома и соблюдает порядок `depends_on`. Обычно используется для поднятия всего стека.
- `docker compose run <сервис> <команда>`: Запускает **один** сервис с одноразовой командой. Не запускает зависимые сервисы по умолчанию (используйте `--service-ports` для маппинга портов, `--rm` для очистки). Используется для запуска миграций, тестов или административных задач.
</details>

<details>
<summary><strong>14. Как работает depends_on и каковы его ограничения?</strong></summary>
<br>

`depends_on` контролирует **порядок запуска** — гарантирует, что сервис A стартует до сервиса B. Однако он ждёт только **запуска** контейнера, а не **готовности** приложения внутри.

Например, контейнер базы данных может запуститься за секунды, но PostgreSQL нужно дополнительное время для инициализации. Ваш контейнер приложения запустится и сразу же не сможет подключиться.

Решение: Используйте `depends_on` с `condition` и health check:

```yaml
services:
  db:
    image: postgres:16
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 5s
      timeout: 5s
      retries: 5
  app:
    depends_on:
      db:
        condition: service_healthy
```
</details>

<details>
<summary><strong>15. Когда вы выбрали бы Docker Swarm вместо Kubernetes?</strong></summary>
<br>

**Docker Swarm**: Встроен в Docker, нулевая дополнительная настройка. Лучше всего для малых и средних развёртываний, где важна простота. Использует те же файлы Docker Compose. Ограниченная экосистема и сообщество по сравнению с Kubernetes. Подходит для команд без выделенных платформенных инженеров.

**Kubernetes**: Отраслевой стандарт оркестрации контейнеров в масштабе. Поддерживает автомасштабирование, плавные обновления, service mesh, custom resource definitions и огромную экосистему (Helm, Istio, ArgoCD). Более высокая сложность и кривая обучения. Необходим для крупномасштабных, мультикомандных и мультиоблачных развёртываний.

Правило: Если у вас менее 20 сервисов и небольшая команда, Swarm достаточен. Сверх того Kubernetes стоит инвестиций.
</details>

## Продакшен и устранение неполадок

<details>
<summary><strong>16. Как уменьшить размер образа Docker?</strong></summary>
<br>

1. **Используйте многоэтапные сборки** — не включайте инструменты сборки в финальный образ.
2. **Используйте минимальные базовые образы** — `alpine` (~5МБ) вместо `ubuntu` (~75МБ).
3. **Объединяйте команды RUN** — каждый `RUN` создаёт слой. Цепочкой через `&&` объединяйте команды и очищайте в том же слое.
4. **Используйте .dockerignore** — исключите `node_modules`, `.git`, тестовые файлы, документацию из контекста сборки.
5. **Упорядочивайте слои по частоте изменений** — редко изменяемые слои (зависимости) размещайте перед часто изменяемыми (исходный код) для максимизации попаданий в кэш.
</details>

<details>
<summary><strong>17. Контейнер постоянно перезапускается. Как вы его отлаживаете?</strong></summary>
<br>

Пошаговый подход:
1. `docker ps -a` — проверьте код выхода. Код 137 = убит OOM. Код 1 = ошибка приложения.
2. `docker logs <container>` — прочитайте логи приложения на предмет трассировок стека или сообщений об ошибках.
3. `docker inspect <container>` — проверьте `State.OOMKilled`, лимиты ресурсов и переменные окружения.
4. `docker run -it --entrypoint /bin/sh <image>` — запустите интерактивную оболочку для ручной отладки среды.
5. `docker stats` — проверьте, достигает ли контейнер лимитов памяти или CPU.
6. Проверьте `docker events` — ищите сигналы kill или OOM-события от демона.
</details>

<details>
<summary><strong>18. В чём разница между docker stop и docker kill?</strong></summary>
<br>

- `docker stop` отправляет **SIGTERM** основному процессу (PID 1) и ждёт период grace (по умолчанию 10 секунд). Если процесс не завершается, Docker отправляет SIGKILL. Это позволяет приложению выполнить корректное завершение (закрыть соединения, очистить буферы, сохранить состояние).
- `docker kill` немедленно отправляет **SIGKILL**. Процесс завершается без какой-либо возможности очистки. Используйте только когда контейнер не отвечает.

Лучшая практика: Всегда используйте `docker stop` в продакшене. Убедитесь, что ваше приложение корректно обрабатывает SIGTERM.
</details>

<details>
<summary><strong>19. Как управлять секретами в Docker?</strong></summary>
<br>

**Никогда** не встраивайте секреты в образы (ENV в Dockerfile, COPY файлов .env). Они сохраняются в слоях образа и видны через `docker history`.

Подходы по уровню зрелости:
- **Базовый**: Передавайте секреты через `--env-file` во время выполнения (файл не включён в образ).
- **Лучше**: Используйте секреты Docker Swarm или Kubernetes secrets (монтируются как файлы, не как переменные окружения).
- **Оптимально**: Используйте внешний менеджер секретов (HashiCorp Vault, AWS Secrets Manager, Azure Key Vault) и внедряйте секреты во время выполнения через sidecar или init container.
</details>

<details>
<summary><strong>20. Что такое health check Docker и почему он критически важен?</strong></summary>
<br>

Health check — это команда, которую Docker периодически выполняет внутри контейнера для проверки того, что приложение действительно работает — а не просто что процесс запущен.

```dockerfile
HEALTHCHECK --interval=30s --timeout=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1
```

Без health check Docker знает только, жив ли процесс (PID существует). С health check Docker знает, **здорово** ли приложение (отвечает на запросы). Это критически важно для:
- **Балансировщиков нагрузки**: Направлять трафик только на здоровые контейнеры.
- **Оркестраторов**: Автоматически перезапускать нездоровые контейнеры.
- **depends_on**: Ожидать фактической готовности, а не просто запуска процесса.
</details>
