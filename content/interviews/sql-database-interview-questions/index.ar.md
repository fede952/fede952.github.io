---
title: "أسئلة مقابلات SQL وتصميم قواعد البيانات (المستوى المتقدم)"
description: "20 سؤال مقابلة متقدم في SQL وقواعد البيانات لأدوار Backend المتقدمة و DBA. يغطي تحسين الاستعلامات، التطبيع، الفهرسة، المعاملات، خصائص ACID، والأمان."
date: 2026-02-11
tags: ["sql", "interview", "database", "backend"]
keywords: ["أسئلة مقابلة استعلامات sql", "تطبيع قواعد البيانات", "خصائص acid", "منع حقن sql", "مقابلة فهارس قواعد البيانات", "أسئلة ربط sql", "مقابلة postgresql", "أسئلة مقابلة mysql", "أنماط تصميم قواعد البيانات", "ضبط أداء sql"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "أسئلة مقابلات SQL وتصميم قواعد البيانات (المستوى المتقدم)",
    "description": "20 سؤال مقابلة متقدم في SQL وقواعد البيانات يغطي التحسين، التطبيع، الفهرسة، المعاملات، والأمان.",
    "proficiencyLevel": "Advanced",
    "inLanguage": "ar"
  }
---

## تهيئة النظام

SQL هي لغة البيانات، وقواعد البيانات هي العمود الفقري لكل تطبيق. تختبر مقابلات المستوى المتقدم قدرتك على كتابة استعلامات فعالة، وتصميم مخططات مطبعة، وفهم عزل المعاملات، وتحسين الأداء باستخدام الفهارس، ومنع حقن SQL. سواء كان الدور مهندس Backend، أو DBA، أو مهندس بيانات، أو محلل أمني، فإن هذه الأسئلة العشرين تغطي المفاهيم التي يسألها المحاورون باستمرار — مع إجابات تُظهر خبرة الإنتاج.

**هل تحتاج إلى مرجع سريع لـ SQL؟** احتفظ بـ [ورقة الغش لحقن SQL واستعلامات قواعد البيانات](/cheatsheets/sql-injection-payloads-database/) مفتوحة أثناء تحضيرك.

---

## أساسيات الاستعلامات

<details>
<summary><strong>1. ما هو ترتيب تنفيذ استعلام SQL؟</strong></summary>
<br>

استعلامات SQL **لا** تُنفذ بالترتيب الذي تكتبها به. ترتيب التنفيذ الفعلي هو:

1. **FROM** / **JOIN** — تحديد الجداول وربطها.
2. **WHERE** — تصفية الصفوف قبل التجميع.
3. **GROUP BY** — تجميع الصفوف المتبقية.
4. **HAVING** — تصفية المجموعات (بعد التجميع).
5. **SELECT** — اختيار الأعمدة/التعبيرات المراد إرجاعها.
6. **DISTINCT** — إزالة الصفوف المكررة.
7. **ORDER BY** — ترتيب النتائج.
8. **LIMIT** / **OFFSET** — تقييد عدد الصفوف المُرجعة.

لهذا السبب لا يمكنك استخدام اسم مستعار لعمود معرف في SELECT داخل عبارة WHERE — يتم تنفيذ WHERE قبل SELECT.
</details>

<details>
<summary><strong>2. اشرح الفرق بين WHERE و HAVING.</strong></summary>
<br>

- **WHERE** يصفي الصفوف **قبل** التجميع (GROUP BY). يعمل على الصفوف الفردية ولا يمكنه استخدام دوال التجميع.
- **HAVING** يصفي المجموعات **بعد** التجميع. يعمل على نتائج GROUP BY ويمكنه استخدام دوال التجميع.

```sql
-- WHERE: Filter individual orders over $100
SELECT customer_id, SUM(total) as total_spent
FROM orders
WHERE total > 100
GROUP BY customer_id;

-- HAVING: Filter customers who spent over $1000 total
SELECT customer_id, SUM(total) as total_spent
FROM orders
GROUP BY customer_id
HAVING SUM(total) > 1000;
```

الأداء: WHERE دائماً أفضل عندما يكون ممكناً — فهو يقلل مجموعة البيانات قبل عملية GROUP BY المكلفة.
</details>

<details>
<summary><strong>3. ما الفرق بين INNER JOIN و LEFT JOIN و RIGHT JOIN و FULL OUTER JOIN؟</strong></summary>
<br>

- **INNER JOIN**: يُرجع فقط الصفوف التي لها قيم متطابقة في **كلا** الجدولين. الصفوف غير المتطابقة مستبعدة.
- **LEFT JOIN**: يُرجع جميع الصفوف من الجدول الأيسر، والصفوف المتطابقة من الجدول الأيمن. إذا لم يكن هناك تطابق، تكون الأعمدة اليمنى NULL.
- **RIGHT JOIN**: يُرجع جميع الصفوف من الجدول الأيمن، والصفوف المتطابقة من الجدول الأيسر. إذا لم يكن هناك تطابق، تكون الأعمدة اليسرى NULL.
- **FULL OUTER JOIN**: يُرجع جميع الصفوف من كلا الجدولين. حيث لا يوجد تطابق، يكون الجانب المفقود NULL.

عملياً، يُستخدم LEFT JOIN حوالي 90% من الوقت. يمكن دائماً إعادة كتابة RIGHT JOIN كـ LEFT JOIN بتبديل ترتيب الجداول.
</details>

<details>
<summary><strong>4. ما الفرق بين UNION و UNION ALL؟</strong></summary>
<br>

- **UNION**: يجمع نتائج استعلامين و**يزيل الصفوف المكررة**. يتطلب عملية فرز/إزالة تكرار داخلية.
- **UNION ALL**: يجمع النتائج **بدون إزالة التكرارات**. أسرع لأنه لا يحتاج إلى إزالة التكرار.

استخدم دائماً `UNION ALL` ما لم تكن بحاجة تحديداً إلى إزالة التكرار. عملية الفرز الضمنية لـ `UNION` يمكن أن تكون مكلفة على مجموعات البيانات الكبيرة.

كلاهما يتطلب نفس عدد الأعمدة بأنواع بيانات متوافقة في كل SELECT.
</details>

## تصميم قواعد البيانات

<details>
<summary><strong>5. اشرح تطبيع قواعد البيانات (من 1NF إلى 3NF).</strong></summary>
<br>

التطبيع يقلل تكرار البيانات ويمنع حالات شذوذ التحديث:

- **1NF** (الشكل الطبيعي الأول): كل عمود يحتوي على قيم ذرية (غير قابلة للتجزئة). لا توجد مجموعات متكررة. كل صف فريد (له مفتاح أساسي).
- **2NF**: يستوفي 1NF + كل عمود غير مفتاحي يعتمد على المفتاح الأساسي **بالكامل** (وليس جزءاً فقط من مفتاح مركب). يزيل التبعيات الجزئية.
- **3NF**: يستوفي 2NF + كل عمود غير مفتاحي يعتمد **مباشرة** على المفتاح الأساسي، وليس على عمود غير مفتاحي آخر. يزيل التبعيات المتعدية.

مثال على انتهاك 3NF: جدول يحتوي على `(order_id, customer_id, customer_name)` — `customer_name` يعتمد على `customer_id`، وليس على `order_id`. الحل: نقل `customer_name` إلى جدول `customers` منفصل.
</details>

<details>
<summary><strong>6. متى تقوم بإلغاء تطبيع قاعدة البيانات عمداً؟</strong></summary>
<br>

إلغاء التطبيع مبرر عندما:

1. **أداء القراءة حرج**: لوحات المعلومات، استعلامات التحليل التي تربط العديد من الجداول. حساب التجميعات مسبقاً أو تسطيح التسلسلات الهرمية يتجنب عمليات الربط المكلفة وقت الاستعلام.
2. **طبقات التخزين المؤقت**: العروض المادية أو جداول الملخصات التي يتم تحديثها دورياً.
3. **NoSQL/مخازن المستندات**: البيانات تُخزن كمستندات كاملة (MongoDB). تضمين البيانات المرتبطة يتجنب عمليات الربط كلياً.
4. **Event sourcing/CQRS**: نموذج الكتابة مُطبع، نموذج القراءة غير مُطبع.

المقايضة: قراءات أسرع على حساب كتابات أكثر تعقيداً (يجب تحديث أماكن متعددة) وعدم اتساق محتمل في البيانات.
</details>

<details>
<summary><strong>7. ما هي خصائص ACID؟</strong></summary>
<br>

ACID تضمن معاملات قاعدة بيانات موثوقة:

- **الذرية (Atomicity)**: المعاملة هي كل شيء أو لا شيء. إذا فشل أي جزء، يتم التراجع عن المعاملة بالكامل. لا توجد تحديثات جزئية.
- **الاتساق (Consistency)**: المعاملة تنقل قاعدة البيانات من حالة صالحة إلى حالة صالحة أخرى. جميع القيود (المفاتيح الخارجية، الفحوصات، المشغلات) مستوفاة.
- **العزل (Isolation)**: المعاملات المتزامنة لا تتداخل مع بعضها البعض. كل معاملة ترى لقطة متسقة من البيانات.
- **المتانة (Durability)**: بمجرد تأكيد المعاملة، فإنها تنجو من أعطال النظام. البيانات تُكتب في تخزين غير متطاير (WAL، سجلات redo).

ACID هي الخاصية المميزة لقواعد البيانات العلائقية (PostgreSQL، MySQL InnoDB). العديد من قواعد بيانات NoSQL تضحي ببعض خصائص ACID من أجل قابلية التوسع (BASE: متاح أساسياً، حالة مرنة، متسق في النهاية).
</details>

<details>
<summary><strong>8. اشرح مستويات عزل المعاملات.</strong></summary>
<br>

من الأقل إلى الأكثر صرامة:

1. **Read Uncommitted**: يمكنه قراءة التغييرات غير المؤكدة من معاملات أخرى (**القراءات القذرة**). نادراً ما يُستخدم.
2. **Read Committed** (الافتراضي في PostgreSQL): يقرأ فقط البيانات المؤكدة. لكن إعادة قراءة نفس الصف قد تُرجع قيماً مختلفة إذا تم تأكيد معاملة أخرى في هذه الأثناء (**القراءات غير القابلة للتكرار**).
3. **Repeatable Read** (الافتراضي في MySQL InnoDB): إعادة قراءة نفس الصف تُرجع دائماً نفس القيمة ضمن معاملة. لكن الصفوف الجديدة المُدخلة من معاملات أخرى قد تظهر (**القراءات الشبحية**).
4. **Serializable**: عزل كامل. المعاملات تُنفذ كما لو كانت تسلسلية (واحدة تلو الأخرى). يمنع جميع الشذوذات لكن له أعلى تكلفة أداء (عبء القفل/MVCC).

اختر بناءً على التطبيق: المعاملات المالية تحتاج Serializable؛ قراءات تطبيقات الويب عادةً تستخدم Read Committed.
</details>

## الفهرسة والأداء

<details>
<summary><strong>9. ما هو فهرس قاعدة البيانات وكيف يعمل؟</strong></summary>
<br>

الفهرس هو هيكل بيانات منفصل (عادةً **شجرة B** أو **شجرة B+**) يخزن نسخة مرتبة من أعمدة محددة مع مؤشرات إلى الصفوف الكاملة. يمكّن قاعدة البيانات من العثور على الصفوف دون مسح الجدول بالكامل (مسح الجدول الكامل).

تشبيه: فهرس الكتاب يربط الكلمات المفتاحية بأرقام الصفحات. بدونه، يجب قراءة كل صفحة للعثور على موضوع.

المقايضات:
- **قراءات أسرع**: SELECT مع WHERE، JOIN، ORDER BY على الأعمدة المفهرسة.
- **كتابات أبطأ**: كل INSERT، UPDATE، DELETE يجب أن يحدث الفهرس أيضاً.
- **تخزين أكثر**: الفهرس يشغل مساحة قرص متناسبة مع البيانات المفهرسة.

القاعدة: قم بفهرسة الأعمدة التي تظهر بشكل متكرر في عبارات WHERE، JOIN ON، ORDER BY، و GROUP BY.
</details>

<details>
<summary><strong>10. ما الفرق بين الفهرس المتجمع وغير المتجمع؟</strong></summary>
<br>

- **الفهرس المتجمع**: يحدد **الترتيب الفعلي** للبيانات على القرص. يمكن للجدول أن يحتوي على فهرس متجمع واحد فقط (عادةً المفتاح الأساسي). عقد الأوراق في شجرة B تحتوي على صفوف البيانات الفعلية.
- **الفهرس غير المتجمع**: هيكل منفصل مع مؤشرات إلى صفوف البيانات. يمكن للجدول أن يحتوي على عدة فهارس غير متجمعة. عقد الأوراق تحتوي على قيم الأعمدة المفهرسة ومرجع (محدد موقع الصف) إلى البيانات الفعلية.

في PostgreSQL، لا يوجد مفهوم صريح للفهرس المتجمع — الأمر `CLUSTER` يعيد ترتيب البيانات فعلياً مرة واحدة، لكنه لا يُحافظ عليه تلقائياً. InnoDB (MySQL) يجمع البيانات دائماً حسب المفتاح الأساسي.
</details>

<details>
<summary><strong>11. كيف تقوم بتحسين استعلام بطيء؟</strong></summary>
<br>

نهج تدريجي:

1. **EXPLAIN ANALYZE**: اقرأ خطة الاستعلام. ابحث عن المسح التسلسلي (Seq Scan)، وتقديرات الصفوف العالية، وعمليات الفرز على مجموعات البيانات الكبيرة.
2. **أضف الفهارس المفقودة**: إذا كانت أعمدة WHERE/JOIN تفتقر إلى فهارس، أنشئها.
3. **أعد كتابة الاستعلام**: استبدل الاستعلامات الفرعية بـ JOINs. استخدم EXISTS بدلاً من IN للمجموعات الفرعية الكبيرة. تجنب SELECT * — حدد فقط الأعمدة المطلوبة.
4. **تجنب الدوال على الأعمدة المفهرسة**: `WHERE YEAR(created_at) = 2026` لا يمكنه استخدام فهرس على `created_at`. أعد الكتابة كـ `WHERE created_at >= '2026-01-01' AND created_at < '2027-01-01'`.
5. **ترقيم الصفحات**: استخدم ترقيم الصفحات بالمفتاح (`WHERE id > last_seen_id LIMIT 20`) بدلاً من `OFFSET` (الذي يمسح ويتجاهل الصفوف).
6. **الإحصائيات**: شغّل `ANALYZE` (PostgreSQL) لتحديث إحصائيات الجدول حتى يتخذ المخطط قرارات أفضل.
</details>

<details>
<summary><strong>12. ما هو الفهرس التغطوي؟</strong></summary>
<br>

الفهرس التغطوي يحتوي على جميع الأعمدة المطلوبة لتلبية استعلام، لذلك لا تحتاج قاعدة البيانات أبداً للوصول إلى بيانات الجدول الفعلية (لا "جلب من الكومة" أو "بحث الإشارة المرجعية"). يتم الرد على الاستعلام بالكامل من الفهرس.

```sql
-- Query
SELECT email, name FROM users WHERE email = 'user@example.com';

-- Covering index (includes all needed columns)
CREATE INDEX idx_users_email_name ON users(email) INCLUDE (name);
```

PostgreSQL يستخدم `INCLUDE` للأعمدة غير المفتاحية. MySQL يستخدم فهارس مركبة حيث تُلحق الأعمدة الإضافية. الفهارس التغطوية يمكن أن تحسن أداء القراءة بشكل كبير لأنماط استعلام محددة.
</details>

## مفاهيم متقدمة

<details>
<summary><strong>13. ما هو تعبير الجدول المشترك (CTE) ومتى تستخدمه؟</strong></summary>
<br>

CTE هو مجموعة نتائج مؤقتة مسماة معرفة ضمن استعلام واحد باستخدام `WITH`:

```sql
WITH high_spenders AS (
    SELECT customer_id, SUM(total) as total_spent
    FROM orders
    GROUP BY customer_id
    HAVING SUM(total) > 10000
)
SELECT c.name, hs.total_spent
FROM customers c
JOIN high_spenders hs ON c.id = hs.customer_id;
```

استخدم CTEs لـ: القابلية للقراءة (تقسيم الاستعلامات المعقدة إلى خطوات منطقية)، الاستعلامات التكرارية (البيانات الهرمية مثل المخططات التنظيمية)، واستبدال الاستعلامات الفرعية المعقدة. ملاحظة: في PostgreSQL < 12، تعمل CTEs كحواجز تحسين (لا يتم دمجها). في PostgreSQL 12+، يمكن دمج CTEs غير التكرارية.
</details>

<details>
<summary><strong>14. ما هي دوال النافذة وكيف تختلف عن GROUP BY؟</strong></summary>
<br>

دوال النافذة تحسب قيمة عبر مجموعة من الصفوف **بدون طيها في صف واحد** (على عكس GROUP BY).

```sql
-- GROUP BY: One row per department
SELECT department, AVG(salary) FROM employees GROUP BY department;

-- Window function: Every row, with department average added
SELECT name, department, salary,
       AVG(salary) OVER (PARTITION BY department) as dept_avg,
       RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank
FROM employees;
```

دوال النافذة الشائعة: `ROW_NUMBER()`، `RANK()`، `DENSE_RANK()`، `LAG()`، `LEAD()`، `SUM() OVER()`، `AVG() OVER()`. ضرورية للتحليلات والتقارير وترقيم الصفحات.
</details>

<details>
<summary><strong>15. ما هو الجمود (deadlock) وكيف تمنعه؟</strong></summary>
<br>

يحدث الجمود عندما تنتظر معاملتان بعضهما لتحرير الأقفال، مما يخلق تبعية دائرية. لا يمكن لأي منهما المتابعة.

مثال:
- المعاملة A تقفل الصف 1، تريد الصف 2.
- المعاملة B تقفل الصف 2، تريد الصف 1.
- كلاهما ينتظر إلى الأبد.

تكتشف قاعدة البيانات حالات الجمود وتقتل معاملة واحدة ("الضحية")، وتقوم بالتراجع عنها.

المنع:
1. **ترتيب قفل متسق**: اقفل الموارد دائماً بنفس الترتيب عبر جميع المعاملات.
2. **معاملات قصيرة**: احتفظ بالأقفال لأقل وقت ممكن.
3. **مهلة القفل**: عيّن `lock_timeout` حتى تفشل المعاملات بسرعة بدلاً من الانتظار إلى أجل غير مسمى.
4. **تخفيض مستوى العزل**: مستويات العزل الأقل تتطلب أقفالاً أقل.
</details>

## الأمان

<details>
<summary><strong>16. ما هو حقن SQL وكيف تمنعه؟</strong></summary>
<br>

يحدث حقن SQL عندما يتم ربط مدخلات المستخدم مباشرة في استعلام SQL، مما يسمح للمهاجم بتعديل منطق الاستعلام.

```python
# VULNERABLE
query = f"SELECT * FROM users WHERE username = '{user_input}'"
# If user_input = "' OR 1=1--", returns all users

# SAFE: Parameterized query
cursor.execute("SELECT * FROM users WHERE username = %s", (user_input,))
```

المنع:
1. **الاستعلامات المُعلمة** (العبارات المُعدة) — الدفاع الأول. يُعامل المدخل كبيانات، وليس أبداً كـ SQL.
2. **ORM** (SQLAlchemy، Django ORM) — يُنشئ استعلامات مُعلمة تلقائياً.
3. **التحقق من المدخلات** — قائمة بيضاء بالتنسيقات المتوقعة (معرفات رقمية، أنماط بريد إلكتروني).
4. **مبدأ أقل الصلاحيات** — يجب أن يكون لمستخدم قاعدة البيانات فقط SELECT/INSERT/UPDATE على الجداول المطلوبة، وأبداً DROP أو GRANT.
</details>

<details>
<summary><strong>17. ما هو مبدأ أقل الصلاحيات في أمان قواعد البيانات؟</strong></summary>
<br>

يجب أن يمتلك كل مستخدم قاعدة بيانات أو تطبيق فقط الأذونات الدنيا اللازمة لأداء عمله.

```sql
-- Application user: Only needs CRUD on specific tables
CREATE USER app_user WITH PASSWORD 'secure_password';
GRANT SELECT, INSERT, UPDATE ON users, orders TO app_user;
-- No DELETE, no DROP, no access to other tables

-- Admin user: Full access but should not be used by the application
CREATE USER admin_user WITH PASSWORD 'admin_password';
GRANT ALL PRIVILEGES ON DATABASE myapp TO admin_user;
```

لا تستخدم أبداً المستخدم المتميز لقاعدة البيانات (postgres، root) لاتصالات التطبيق. إذا تم اختراق التطبيق عبر حقن SQL، فإن المهاجم يحصل فقط على أذونات المستخدم المحدود.
</details>

## سيناريوهات عملية

<details>
<summary><strong>18. كيف تصمم مخططاً لعلاقة متعدد-لمتعدد؟</strong></summary>
<br>

استخدم **جدول ربط** (يُسمى أيضاً جدول جسر أو جدول ارتباط):

```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200)
);

-- Junction table
CREATE TABLE enrollments (
    student_id INT REFERENCES students(id),
    course_id INT REFERENCES courses(id),
    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    grade VARCHAR(2),
    PRIMARY KEY (student_id, course_id)
);
```

جدول الربط يحمل المفاتيح الخارجية لكلا الجدولين، مما ينشئ علاقة متعدد-لمتعدد. يمكنه أيضاً حمل سمات خاصة بالعلاقة (enrolled_at، grade).
</details>

<details>
<summary><strong>19. اكتب استعلاماً لإيجاد ثاني أعلى راتب في كل قسم.</strong></summary>
<br>

```sql
-- Using window function (cleanest approach)
WITH ranked AS (
    SELECT name, department, salary,
           DENSE_RANK() OVER (
               PARTITION BY department
               ORDER BY salary DESC
           ) as rank
    FROM employees
)
SELECT name, department, salary
FROM ranked
WHERE rank = 2;
```

لماذا `DENSE_RANK` بدلاً من `ROW_NUMBER`: إذا تعادل موظفان في أعلى راتب، فإن `DENSE_RANK` يعين بشكل صحيح الرتبة 2 للراتب التالي. `ROW_NUMBER` سيعين بشكل عشوائي الرتبتين 1 و 2 للموظفين المتعادلين.
</details>

<details>
<summary><strong>20. كيف تتعامل مع ترحيل قواعد البيانات في بيئة الإنتاج؟</strong></summary>
<br>

1. **استخدم أداة ترحيل**: Flyway، Liquibase (Java)، Alembic (Python/SQLAlchemy)، Django migrations، Prisma Migrate. لا تشغّل أبداً DDL خام في الإنتاج.
2. **التحكم بإصدارات الترحيلات**: كل ترحيل هو ملف مرقم في المستودع. تُطبق الترحيلات بالترتيب وتُتبع في جدول البيانات الوصفية.
3. **تغييرات متوافقة مع الخلف**: أضف الأعمدة الجديدة كـ nullable أولاً. انشر كود التطبيق الذي يستخدم العمود الجديد. ثم أضف قيد NOT NULL إذا لزم الأمر. لا تعيد تسمية أو تحذف الأعمدة بدون فترة إهمال.
4. **اختبر الترحيلات**: شغّلها على نسخة staging من بيانات الإنتاج قبل تطبيقها في الإنتاج.
5. **خطة التراجع**: كل ترحيل يجب أن يكون له سكريبت تراجع مقابل. اختبر التراجعات قبل النشر.
6. **بدون توقف**: استخدم تقنيات مثل أنماط التوسيع/الانكماش، الجداول الشبحية (gh-ost لـ MySQL)، أو DDL عبر الإنترنت (ALTER TABLE غير المحجوب في PostgreSQL).
</details>
