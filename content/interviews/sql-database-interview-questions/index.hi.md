---
title: "SQL और डेटाबेस डिज़ाइन इंटरव्यू प्रश्न (सीनियर स्तर)"
description: "सीनियर बैकएंड और DBA भूमिकाओं के लिए 20 उन्नत SQL और डेटाबेस इंटरव्यू प्रश्न। क्वेरी ऑप्टिमाइज़ेशन, नॉर्मलाइज़ेशन, इंडेक्सिंग, ट्रांज़ैक्शन, ACID गुण, और सुरक्षा को कवर करता है।"
date: 2026-02-11
tags: ["sql", "interview", "database", "backend"]
keywords: ["sql क्वेरी इंटरव्यू प्रश्न", "डेटाबेस नॉर्मलाइज़ेशन", "acid गुण", "sql इंजेक्शन रोकथाम", "डेटाबेस इंडेक्स इंटरव्यू", "sql जॉइन प्रश्न", "postgresql इंटरव्यू", "mysql इंटरव्यू प्रश्न", "डेटाबेस डिज़ाइन पैटर्न", "sql प्रदर्शन ट्यूनिंग"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "SQL और डेटाबेस डिज़ाइन इंटरव्यू प्रश्न (सीनियर स्तर)",
    "description": "ऑप्टिमाइज़ेशन, नॉर्मलाइज़ेशन, इंडेक्सिंग, ट्रांज़ैक्शन, और सुरक्षा को कवर करने वाले 20 उन्नत SQL और डेटाबेस इंटरव्यू प्रश्न।",
    "proficiencyLevel": "Advanced",
    "inLanguage": "hi"
  }
---

## सिस्टम इनिट

SQL डेटा की भाषा है, और डेटाबेस हर एप्लिकेशन की रीढ़ हैं। सीनियर-स्तर के इंटरव्यू आपकी कुशल क्वेरी लिखने, नॉर्मलाइज़्ड स्कीमा डिज़ाइन करने, ट्रांज़ैक्शन आइसोलेशन को समझने, इंडेक्स के साथ प्रदर्शन ऑप्टिमाइज़ करने, और SQL इंजेक्शन रोकने की क्षमता का परीक्षण करते हैं। चाहे भूमिका बैकएंड इंजीनियर, DBA, डेटा इंजीनियर, या सिक्योरिटी एनालिस्ट हो, ये 20 प्रश्न उन अवधारणाओं को कवर करते हैं जो इंटरव्यूअर लगातार पूछते हैं — ऐसे उत्तरों के साथ जो प्रोडक्शन अनुभव दर्शाते हैं।

**SQL का त्वरित संदर्भ चाहिए?** अपनी तैयारी के दौरान हमारा [SQL इंजेक्शन और डेटाबेस क्वेरी चीटशीट](/cheatsheets/sql-injection-payloads-database/) खुला रखें।

---

## क्वेरी मूलभूत तत्व

<details>
<summary><strong>1. SQL क्वेरी के निष्पादन का क्रम क्या है?</strong></summary>
<br>

SQL क्वेरी आपके लिखने के क्रम में निष्पादित **नहीं** होतीं। वास्तविक निष्पादन क्रम यह है:

1. **FROM** / **JOIN** — टेबल की पहचान करें और उन्हें जोड़ें।
2. **WHERE** — ग्रुपिंग से पहले पंक्तियों को फ़िल्टर करें।
3. **GROUP BY** — शेष पंक्तियों को ग्रुप करें।
4. **HAVING** — ग्रुप्स को फ़िल्टर करें (एग्रीगेशन के बाद)।
5. **SELECT** — चुनें कि कौन से कॉलम/एक्सप्रेशन लौटाने हैं।
6. **DISTINCT** — डुप्लिकेट पंक्तियाँ हटाएँ।
7. **ORDER BY** — परिणामों को सॉर्ट करें।
8. **LIMIT** / **OFFSET** — लौटाई गई पंक्तियों की संख्या सीमित करें।

इसीलिए आप SELECT में परिभाषित कॉलम एलियास को WHERE क्लॉज़ के अंदर उपयोग नहीं कर सकते — WHERE, SELECT से पहले निष्पादित होता है।
</details>

<details>
<summary><strong>2. WHERE और HAVING के बीच अंतर समझाइए।</strong></summary>
<br>

- **WHERE** एग्रीगेशन (GROUP BY) से **पहले** पंक्तियों को फ़िल्टर करता है। यह व्यक्तिगत पंक्तियों पर काम करता है और एग्रीगेट फ़ंक्शन का उपयोग नहीं कर सकता।
- **HAVING** एग्रीगेशन के **बाद** ग्रुप्स को फ़िल्टर करता है। यह GROUP BY के परिणामों पर काम करता है और एग्रीगेट फ़ंक्शन का उपयोग कर सकता है।

```sql
-- WHERE: Filter individual orders over $100
SELECT customer_id, SUM(total) as total_spent
FROM orders
WHERE total > 100
GROUP BY customer_id;

-- HAVING: Filter customers who spent over $1000 total
SELECT customer_id, SUM(total) as total_spent
FROM orders
GROUP BY customer_id
HAVING SUM(total) > 1000;
```

प्रदर्शन: जब भी संभव हो WHERE हमेशा बेहतर है — यह महंगी GROUP BY ऑपरेशन से पहले डेटासेट को कम करता है।
</details>

<details>
<summary><strong>3. INNER JOIN, LEFT JOIN, RIGHT JOIN, और FULL OUTER JOIN में क्या अंतर है?</strong></summary>
<br>

- **INNER JOIN**: केवल वे पंक्तियाँ लौटाता है जिनमें **दोनों** टेबल में मिलान मान हैं। बेमेल पंक्तियाँ बाहर रखी जाती हैं।
- **LEFT JOIN**: बाईं टेबल की सभी पंक्तियाँ, और दाईं टेबल से मिलान पंक्तियाँ लौटाता है। यदि कोई मिलान नहीं, तो दाईं कॉलम NULL होती हैं।
- **RIGHT JOIN**: दाईं टेबल की सभी पंक्तियाँ, और बाईं टेबल से मिलान पंक्तियाँ लौटाता है। यदि कोई मिलान नहीं, तो बाईं कॉलम NULL होती हैं।
- **FULL OUTER JOIN**: दोनों टेबल की सभी पंक्तियाँ लौटाता है। जहाँ कोई मिलान नहीं, गायब पक्ष NULL है।

व्यवहार में, LEFT JOIN लगभग 90% बार उपयोग किया जाता है। RIGHT JOIN को हमेशा टेबल क्रम बदलकर LEFT JOIN के रूप में दोबारा लिखा जा सकता है।
</details>

<details>
<summary><strong>4. UNION और UNION ALL में क्या अंतर है?</strong></summary>
<br>

- **UNION**: दो क्वेरी के परिणामों को जोड़ता है और **डुप्लिकेट पंक्तियों को हटाता** है। आंतरिक रूप से सॉर्ट/डीडुप ऑपरेशन की आवश्यकता होती है।
- **UNION ALL**: **डुप्लिकेट हटाए बिना** परिणामों को जोड़ता है। तेज़ क्योंकि डीडुप की आवश्यकता नहीं है।

जब तक आपको विशेष रूप से डीडुप्लिकेशन की आवश्यकता न हो, हमेशा `UNION ALL` का उपयोग करें। `UNION` का अंतर्निहित सॉर्ट ऑपरेशन बड़े डेटासेट पर महंगा हो सकता है।

दोनों को प्रत्येक SELECT में संगत डेटा प्रकारों वाले समान संख्या में कॉलम की आवश्यकता होती है।
</details>

## डेटाबेस डिज़ाइन

<details>
<summary><strong>5. डेटाबेस नॉर्मलाइज़ेशन (1NF से 3NF) समझाइए।</strong></summary>
<br>

नॉर्मलाइज़ेशन डेटा रिडंडेंसी को कम करता है और अपडेट विसंगतियों को रोकता है:

- **1NF** (प्रथम सामान्य रूप): प्रत्येक कॉलम में एटॉमिक (अविभाज्य) मान होते हैं। कोई दोहराने वाले समूह नहीं। प्रत्येक पंक्ति अद्वितीय है (प्राइमरी की है)।
- **2NF**: 1NF पूरा करता है + प्रत्येक नॉन-की कॉलम **संपूर्ण** प्राइमरी की पर निर्भर करता है (केवल कम्पोजिट की के हिस्से पर नहीं)। आंशिक निर्भरताओं को समाप्त करता है।
- **3NF**: 2NF पूरा करता है + प्रत्येक नॉन-की कॉलम **सीधे** प्राइमरी की पर निर्भर करता है, किसी अन्य नॉन-की कॉलम पर नहीं। ट्रांज़िटिव निर्भरताओं को समाप्त करता है।

3NF उल्लंघन का उदाहरण: `(order_id, customer_id, customer_name)` वाली एक टेबल — `customer_name`, `order_id` पर नहीं बल्कि `customer_id` पर निर्भर है। समाधान: `customer_name` को अलग `customers` टेबल में ले जाएँ।
</details>

<details>
<summary><strong>6. आप जानबूझकर डेटाबेस को डीनॉर्मलाइज़ कब करेंगे?</strong></summary>
<br>

डीनॉर्मलाइज़ेशन तब उचित है जब:

1. **रीड प्रदर्शन महत्वपूर्ण है**: रिपोर्टिंग डैशबोर्ड, कई टेबल को जोड़ने वाली एनालिटिक्स क्वेरी। एग्रीगेट की पूर्व-गणना या हाइरार्की को समतल करना क्वेरी समय पर महंगे जॉइन से बचाता है।
2. **कैशिंग लेयर्स**: मटीरियलाइज़्ड व्यू या सारांश टेबल जो समय-समय पर रिफ्रेश होती हैं।
3. **NoSQL/डॉक्यूमेंट स्टोर**: डेटा पूर्ण दस्तावेज़ों के रूप में संग्रहीत होता है (MongoDB)। संबंधित डेटा एम्बेड करना जॉइन को पूरी तरह से टालता है।
4. **इवेंट सोर्सिंग/CQRS**: राइट मॉडल नॉर्मलाइज़्ड है, रीड मॉडल डीनॉर्मलाइज़्ड है।

ट्रेड-ऑफ: तेज़ रीड के बदले अधिक जटिल राइट (कई जगहों को अपडेट करना होगा) और संभावित डेटा असंगति।
</details>

<details>
<summary><strong>7. ACID गुण क्या हैं?</strong></summary>
<br>

ACID विश्वसनीय डेटाबेस ट्रांज़ैक्शन की गारंटी देता है:

- **एटॉमिसिटी (Atomicity)**: एक ट्रांज़ैक्शन सब-या-कुछ-नहीं है। यदि कोई भी भाग विफल होता है, तो पूरा ट्रांज़ैक्शन रोलबैक हो जाता है। कोई आंशिक अपडेट नहीं।
- **कंसिस्टेंसी (Consistency)**: एक ट्रांज़ैक्शन डेटाबेस को एक वैध स्थिति से दूसरी वैध स्थिति में ले जाता है। सभी बाधाएँ (फ़ॉरेन की, चेक, ट्रिगर) संतुष्ट होती हैं।
- **आइसोलेशन (Isolation)**: समवर्ती ट्रांज़ैक्शन एक-दूसरे में हस्तक्षेप नहीं करते। प्रत्येक ट्रांज़ैक्शन डेटा का एक सुसंगत स्नैपशॉट देखता है।
- **ड्यूरेबिलिटी (Durability)**: एक बार ट्रांज़ैक्शन कमिट हो जाने पर, यह सिस्टम क्रैश के बाद भी बना रहता है। डेटा नॉन-वोलेटाइल स्टोरेज (WAL, redo लॉग) में लिखा जाता है।

ACID रिलेशनल डेटाबेस (PostgreSQL, MySQL InnoDB) की परिभाषित विशेषता है। कई NoSQL डेटाबेस स्केलेबिलिटी के लिए कुछ ACID गुणों का त्याग करते हैं (BASE: Basically Available, Soft state, Eventually consistent)।
</details>

<details>
<summary><strong>8. ट्रांज़ैक्शन आइसोलेशन स्तरों को समझाइए।</strong></summary>
<br>

सबसे कम से सबसे अधिक सख्त तक:

1. **Read Uncommitted**: अन्य ट्रांज़ैक्शन से अनकमिटेड बदलाव पढ़ सकता है (**डर्टी रीड**)। लगभग कभी उपयोग नहीं किया जाता।
2. **Read Committed** (PostgreSQL डिफ़ॉल्ट): केवल कमिटेड डेटा पढ़ता है। लेकिन एक ही पंक्ति को दोबारा पढ़ने पर अलग मान मिल सकते हैं यदि कोई अन्य ट्रांज़ैक्शन बीच में कमिट हो गया (**नॉन-रिपीटेबल रीड**)।
3. **Repeatable Read** (MySQL InnoDB डिफ़ॉल्ट): एक ट्रांज़ैक्शन के भीतर एक ही पंक्ति को दोबारा पढ़ने पर हमेशा वही मान मिलता है। लेकिन अन्य ट्रांज़ैक्शन द्वारा डाली गई नई पंक्तियाँ दिख सकती हैं (**फ़ैंटम रीड**)।
4. **Serializable**: पूर्ण आइसोलेशन। ट्रांज़ैक्शन ऐसे निष्पादित होते हैं जैसे वे क्रमिक हों (एक के बाद एक)। सभी विसंगतियों को रोकता है लेकिन सबसे अधिक प्रदर्शन लागत है (लॉकिंग/MVCC ओवरहेड)।

एप्लिकेशन के आधार पर चुनें: वित्तीय ट्रांज़ैक्शन को Serializable की आवश्यकता होती है; वेब ऐप रीड्स आमतौर पर Read Committed का उपयोग करते हैं।
</details>

## इंडेक्सिंग और प्रदर्शन

<details>
<summary><strong>9. डेटाबेस इंडेक्स क्या है और यह कैसे काम करता है?</strong></summary>
<br>

इंडेक्स एक अलग डेटा संरचना है (आमतौर पर **B-ट्री** या **B+ ट्री**) जो विशिष्ट कॉलम की एक सॉर्ट की गई कॉपी को पूर्ण पंक्तियों के पॉइंटर्स के साथ संग्रहीत करती है। यह डेटाबेस को पूरी टेबल स्कैन किए बिना (फ़ुल टेबल स्कैन) पंक्तियाँ खोजने में सक्षम बनाता है।

उपमा: एक पुस्तक का इंडेक्स कीवर्ड को पेज नंबर से मैप करता है। इसके बिना, आपको किसी विषय को खोजने के लिए हर पेज पढ़ना होगा।

ट्रेड-ऑफ:
- **तेज़ रीड**: इंडेक्स किए गए कॉलम पर WHERE, JOIN, ORDER BY वाला SELECT।
- **धीमी राइट**: हर INSERT, UPDATE, DELETE को इंडेक्स भी अपडेट करना होगा।
- **अधिक स्टोरेज**: इंडेक्स इंडेक्स किए गए डेटा के अनुपात में डिस्क स्पेस लेता है।

नियम: WHERE, JOIN ON, ORDER BY, और GROUP BY क्लॉज़ में बार-बार दिखाई देने वाले कॉलम को इंडेक्स करें।
</details>

<details>
<summary><strong>10. क्लस्टर्ड और नॉन-क्लस्टर्ड इंडेक्स में क्या अंतर है?</strong></summary>
<br>

- **क्लस्टर्ड इंडेक्स**: डिस्क पर डेटा का **भौतिक क्रम** निर्धारित करता है। एक टेबल में केवल एक क्लस्टर्ड इंडेक्स हो सकता है (आमतौर पर प्राइमरी की)। B-ट्री के लीफ नोड में वास्तविक डेटा पंक्तियाँ होती हैं।
- **नॉन-क्लस्टर्ड इंडेक्स**: डेटा पंक्तियों के पॉइंटर्स वाली एक अलग संरचना। एक टेबल में कई नॉन-क्लस्टर्ड इंडेक्स हो सकते हैं। लीफ नोड में इंडेक्स किए गए कॉलम मान और वास्तविक डेटा का संदर्भ (रो लोकेटर) होता है।

PostgreSQL में, कोई स्पष्ट क्लस्टर्ड इंडेक्स अवधारणा नहीं है — `CLUSTER` कमांड एक बार भौतिक रूप से डेटा को पुनर्व्यवस्थित करता है, लेकिन यह स्वचालित रूप से बनाए नहीं रखा जाता। InnoDB (MySQL) हमेशा प्राइमरी की द्वारा डेटा को क्लस्टर करता है।
</details>

<details>
<summary><strong>11. आप एक धीमी क्वेरी को कैसे ऑप्टिमाइज़ करते हैं?</strong></summary>
<br>

चरणबद्ध दृष्टिकोण:

1. **EXPLAIN ANALYZE**: क्वेरी प्लान पढ़ें। सीक्वेंशियल स्कैन (Seq Scan), उच्च पंक्ति अनुमान, और बड़े डेटासेट पर सॉर्ट ऑपरेशन खोजें।
2. **गायब इंडेक्स जोड़ें**: यदि WHERE/JOIN कॉलम में इंडेक्स नहीं हैं, तो बनाएँ।
3. **क्वेरी फिर से लिखें**: सबक्वेरी को JOINs से बदलें। बड़े सबसेट के लिए IN की बजाय EXISTS का उपयोग करें। SELECT * से बचें — केवल आवश्यक कॉलम चुनें।
4. **इंडेक्स किए गए कॉलम पर फ़ंक्शन से बचें**: `WHERE YEAR(created_at) = 2026` `created_at` पर इंडेक्स का उपयोग नहीं कर सकता। इस प्रकार दोबारा लिखें `WHERE created_at >= '2026-01-01' AND created_at < '2027-01-01'`।
5. **पेजिनेशन**: `OFFSET` (जो पंक्तियों को स्कैन करता है और त्यागता है) की बजाय कीसेट पेजिनेशन (`WHERE id > last_seen_id LIMIT 20`) का उपयोग करें।
6. **सांख्यिकी**: टेबल सांख्यिकी अपडेट करने के लिए `ANALYZE` (PostgreSQL) चलाएँ ताकि प्लानर बेहतर निर्णय ले सके।
</details>

<details>
<summary><strong>12. कवरिंग इंडेक्स क्या है?</strong></summary>
<br>

एक कवरिंग इंडेक्स में क्वेरी को संतुष्ट करने के लिए आवश्यक सभी कॉलम होते हैं, इसलिए डेटाबेस को कभी भी वास्तविक टेबल डेटा तक पहुँचने की आवश्यकता नहीं होती (कोई "हीप फ़ेच" या "बुकमार्क लुकअप" नहीं)। क्वेरी पूरी तरह से इंडेक्स से उत्तरित होती है।

```sql
-- Query
SELECT email, name FROM users WHERE email = 'user@example.com';

-- Covering index (includes all needed columns)
CREATE INDEX idx_users_email_name ON users(email) INCLUDE (name);
```

PostgreSQL नॉन-की कॉलम के लिए `INCLUDE` का उपयोग करता है। MySQL कम्पोजिट इंडेक्स का उपयोग करता है जहाँ अतिरिक्त कॉलम जोड़े जाते हैं। कवरिंग इंडेक्स विशिष्ट क्वेरी पैटर्न के लिए रीड प्रदर्शन में नाटकीय सुधार कर सकते हैं।
</details>

## उन्नत अवधारणाएँ

<details>
<summary><strong>13. Common Table Expression (CTE) क्या है और आप इसे कब उपयोग करेंगे?</strong></summary>
<br>

CTE एक नामित अस्थायी परिणाम सेट है जो `WITH` का उपयोग करके एक ही क्वेरी के भीतर परिभाषित होता है:

```sql
WITH high_spenders AS (
    SELECT customer_id, SUM(total) as total_spent
    FROM orders
    GROUP BY customer_id
    HAVING SUM(total) > 10000
)
SELECT c.name, hs.total_spent
FROM customers c
JOIN high_spenders hs ON c.id = hs.customer_id;
```

CTE का उपयोग: पठनीयता (जटिल क्वेरी को तार्किक चरणों में विभाजित करना), पुनरावर्ती क्वेरी (संगठनात्मक चार्ट जैसे पदानुक्रमित डेटा), और जटिल सबक्वेरी को बदलना। नोट: PostgreSQL < 12 में, CTEs ऑप्टिमाइज़ेशन बैरियर के रूप में कार्य करते हैं (इनलाइन नहीं होते)। PostgreSQL 12+ में, नॉन-रिकर्सिव CTEs को इनलाइन किया जा सकता है।
</details>

<details>
<summary><strong>14. विंडो फ़ंक्शन क्या हैं और ये GROUP BY से कैसे भिन्न हैं?</strong></summary>
<br>

विंडो फ़ंक्शन पंक्तियों के एक सेट पर एक मान की गणना करते हैं **बिना उन्हें एक पंक्ति में समेटे** (GROUP BY के विपरीत)।

```sql
-- GROUP BY: One row per department
SELECT department, AVG(salary) FROM employees GROUP BY department;

-- Window function: Every row, with department average added
SELECT name, department, salary,
       AVG(salary) OVER (PARTITION BY department) as dept_avg,
       RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank
FROM employees;
```

सामान्य विंडो फ़ंक्शन: `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `LAG()`, `LEAD()`, `SUM() OVER()`, `AVG() OVER()`। एनालिटिक्स, रिपोर्टिंग, और पेजिनेशन के लिए आवश्यक।
</details>

<details>
<summary><strong>15. डेडलॉक क्या है और आप इसे कैसे रोकते हैं?</strong></summary>
<br>

डेडलॉक तब होता है जब दो ट्रांज़ैक्शन एक-दूसरे के लॉक रिलीज़ होने की प्रतीक्षा करते हैं, एक सर्कुलर निर्भरता बनाते हैं। कोई भी आगे नहीं बढ़ सकता।

उदाहरण:
- ट्रांज़ैक्शन A पंक्ति 1 को लॉक करता है, पंक्ति 2 चाहता है।
- ट्रांज़ैक्शन B पंक्ति 2 को लॉक करता है, पंक्ति 1 चाहता है।
- दोनों हमेशा के लिए प्रतीक्षा करते हैं।

डेटाबेस डेडलॉक का पता लगाता है और एक ट्रांज़ैक्शन ("शिकार") को समाप्त करता है, उसे रोलबैक करता है।

रोकथाम:
1. **सुसंगत लॉक ऑर्डरिंग**: सभी ट्रांज़ैक्शन में हमेशा एक ही क्रम में संसाधनों को लॉक करें।
2. **छोटे ट्रांज़ैक्शन**: लॉक को न्यूनतम आवश्यक समय तक रखें।
3. **लॉक टाइमआउट**: `lock_timeout` सेट करें ताकि ट्रांज़ैक्शन अनिश्चित काल तक प्रतीक्षा करने के बजाय तेज़ी से विफल हों।
4. **आइसोलेशन स्तर कम करें**: कम आइसोलेशन स्तरों को कम लॉक की आवश्यकता होती है।
</details>

## सुरक्षा

<details>
<summary><strong>16. SQL इंजेक्शन क्या है और आप इसे कैसे रोकते हैं?</strong></summary>
<br>

SQL इंजेक्शन तब होता है जब यूज़र इनपुट को सीधे SQL क्वेरी में जोड़ा जाता है, जिससे एक हमलावर क्वेरी लॉजिक को बदल सकता है।

```python
# VULNERABLE
query = f"SELECT * FROM users WHERE username = '{user_input}'"
# If user_input = "' OR 1=1--", returns all users

# SAFE: Parameterized query
cursor.execute("SELECT * FROM users WHERE username = %s", (user_input,))
```

रोकथाम:
1. **पैरामीटराइज़्ड क्वेरी** (प्रिपेर्ड स्टेटमेंट) — नंबर 1 रक्षा। इनपुट को डेटा के रूप में माना जाता है, कभी SQL के रूप में नहीं।
2. **ORM** (SQLAlchemy, Django ORM) — स्वचालित रूप से पैरामीटराइज़्ड क्वेरी जनरेट करता है।
3. **इनपुट वैलिडेशन** — अपेक्षित प्रारूपों की व्हाइटलिस्ट (न्यूमेरिक IDs, ईमेल पैटर्न)।
4. **न्यूनतम विशेषाधिकार का सिद्धांत** — डेटाबेस यूज़र के पास केवल आवश्यक टेबल पर SELECT/INSERT/UPDATE होना चाहिए, कभी DROP या GRANT नहीं।
</details>

<details>
<summary><strong>17. डेटाबेस सुरक्षा में न्यूनतम विशेषाधिकार का सिद्धांत क्या है?</strong></summary>
<br>

प्रत्येक डेटाबेस यूज़र या एप्लिकेशन के पास केवल अपना काम करने के लिए आवश्यक न्यूनतम अनुमतियाँ होनी चाहिए।

```sql
-- Application user: Only needs CRUD on specific tables
CREATE USER app_user WITH PASSWORD 'secure_password';
GRANT SELECT, INSERT, UPDATE ON users, orders TO app_user;
-- No DELETE, no DROP, no access to other tables

-- Admin user: Full access but should not be used by the application
CREATE USER admin_user WITH PASSWORD 'admin_password';
GRANT ALL PRIVILEGES ON DATABASE myapp TO admin_user;
```

एप्लिकेशन कनेक्शन के लिए कभी भी डेटाबेस सुपरयूज़र (postgres, root) का उपयोग न करें। यदि एप्लिकेशन SQL इंजेक्शन के माध्यम से समझौता किया जाता है, तो हमलावर को केवल सीमित यूज़र की अनुमतियाँ मिलती हैं।
</details>

## व्यावहारिक परिदृश्य

<details>
<summary><strong>18. मैनी-टू-मैनी संबंध के लिए स्कीमा कैसे डिज़ाइन करते हैं?</strong></summary>
<br>

एक **जंक्शन टेबल** (जिसे ब्रिज टेबल या एसोसिएटिव टेबल भी कहते हैं) का उपयोग करें:

```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200)
);

-- Junction table
CREATE TABLE enrollments (
    student_id INT REFERENCES students(id),
    course_id INT REFERENCES courses(id),
    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    grade VARCHAR(2),
    PRIMARY KEY (student_id, course_id)
);
```

जंक्शन टेबल दोनों टेबल की फ़ॉरेन कीज़ रखती है, मैनी-टू-मैनी संबंध बनाती है। यह संबंध-विशिष्ट विशेषताएँ (enrolled_at, grade) भी रख सकती है।
</details>

<details>
<summary><strong>19. प्रत्येक विभाग में दूसरी सबसे अधिक वेतन खोजने के लिए क्वेरी लिखें।</strong></summary>
<br>

```sql
-- Using window function (cleanest approach)
WITH ranked AS (
    SELECT name, department, salary,
           DENSE_RANK() OVER (
               PARTITION BY department
               ORDER BY salary DESC
           ) as rank
    FROM employees
)
SELECT name, department, salary
FROM ranked
WHERE rank = 2;
```

`ROW_NUMBER` के बजाय `DENSE_RANK` क्यों: यदि दो कर्मचारी सबसे अधिक वेतन में बराबर हैं, `DENSE_RANK` सही ढंग से अगले वेतन को रैंक 2 देता है। `ROW_NUMBER` बराबर कर्मचारियों को मनमाने ढंग से रैंक 1 और 2 देगा।
</details>

<details>
<summary><strong>20. आप प्रोडक्शन में डेटाबेस माइग्रेशन कैसे संभालते हैं?</strong></summary>
<br>

1. **माइग्रेशन टूल का उपयोग करें**: Flyway, Liquibase (Java), Alembic (Python/SQLAlchemy), Django migrations, Prisma Migrate। प्रोडक्शन में कभी भी कच्चा DDL न चलाएँ।
2. **माइग्रेशन का वर्ज़न कंट्रोल**: प्रत्येक माइग्रेशन रिपॉज़िटरी में एक क्रमांकित फ़ाइल है। माइग्रेशन क्रम में लागू होते हैं और मेटाडेटा टेबल में ट्रैक किए जाते हैं।
3. **पश्चगामी-संगत बदलाव**: पहले नए कॉलम को nullable के रूप में जोड़ें। नए कॉलम का उपयोग करने वाला एप्लिकेशन कोड डिप्लॉय करें। फिर आवश्यकतानुसार NOT NULL बाधा जोड़ें। बिना डेप्रिकेशन अवधि के कभी भी कॉलम का नाम न बदलें या हटाएँ।
4. **माइग्रेशन का परीक्षण करें**: प्रोडक्शन में लागू करने से पहले प्रोडक्शन डेटा की स्टेजिंग कॉपी पर चलाएँ।
5. **रोलबैक योजना**: प्रत्येक माइग्रेशन में एक संबंधित रोलबैक स्क्रिप्ट होनी चाहिए। डिप्लॉयमेंट से पहले रोलबैक का परीक्षण करें।
6. **ज़ीरो-डाउनटाइम**: एक्सपैंडिंग/कॉन्ट्रैक्टिंग पैटर्न, घोस्ट टेबल (MySQL के लिए gh-ost), या ऑनलाइन DDL (PostgreSQL का नॉन-ब्लॉकिंग ALTER TABLE) जैसी तकनीकों का उपयोग करें।
</details>
