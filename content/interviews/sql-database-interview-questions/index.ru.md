---
title: "Вопросы на собеседовании по SQL и проектированию баз данных (уровень Senior)"
description: "20 продвинутых вопросов на собеседовании по SQL и базам данных для ролей Senior Backend и DBA. Охватывает оптимизацию запросов, нормализацию, индексирование, транзакции, свойства ACID и безопасность."
date: 2026-02-11
tags: ["sql", "interview", "database", "backend"]
keywords: ["вопросы собеседование sql запросы", "нормализация баз данных", "свойства acid", "предотвращение sql инъекций", "собеседование индексы баз данных", "вопросы join sql", "собеседование postgresql", "вопросы собеседование mysql", "паттерны проектирования баз данных", "оптимизация производительности sql"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Вопросы на собеседовании по SQL и проектированию баз данных (уровень Senior)",
    "description": "20 продвинутых вопросов на собеседовании по SQL и базам данных, охватывающих оптимизацию, нормализацию, индексирование, транзакции и безопасность.",
    "proficiencyLevel": "Advanced",
    "inLanguage": "ru"
  }
---

## Инициализация системы

SQL — это язык данных, а базы данных — это основа каждого приложения. Собеседования уровня Senior проверяют вашу способность писать эффективные запросы, проектировать нормализованные схемы, понимать изоляцию транзакций, оптимизировать производительность с помощью индексов и предотвращать SQL-инъекции. Будь то роль Backend-инженера, DBA, Data-инженера или аналитика безопасности, эти 20 вопросов охватывают концепции, которые интервьюеры постоянно спрашивают — с ответами, демонстрирующими опыт работы в продакшене.

**Нужна быстрая справка по SQL?** Держите наш [Cheatsheet по SQL-инъекциям и запросам к базам данных](/cheatsheets/sql-injection-payloads-database/) открытым во время подготовки.

---

## Основы запросов

<details>
<summary><strong>1. Каков порядок выполнения SQL-запроса?</strong></summary>
<br>

SQL-запросы **не** выполняются в том порядке, в котором вы их пишете. Фактический порядок выполнения:

1. **FROM** / **JOIN** — определить таблицы и соединить их.
2. **WHERE** — отфильтровать строки перед группировкой.
3. **GROUP BY** — сгруппировать оставшиеся строки.
4. **HAVING** — отфильтровать группы (после агрегации).
5. **SELECT** — выбрать, какие столбцы/выражения вернуть.
6. **DISTINCT** — удалить дублирующиеся строки.
7. **ORDER BY** — отсортировать результаты.
8. **LIMIT** / **OFFSET** — ограничить количество возвращаемых строк.

Вот почему вы не можете использовать псевдоним столбца, определённый в SELECT, внутри WHERE — WHERE выполняется до SELECT.
</details>

<details>
<summary><strong>2. Объясните разницу между WHERE и HAVING.</strong></summary>
<br>

- **WHERE** фильтрует строки **до** агрегации (GROUP BY). Работает с отдельными строками и не может использовать агрегатные функции.
- **HAVING** фильтрует группы **после** агрегации. Работает с результатами GROUP BY и может использовать агрегатные функции.

```sql
-- WHERE: Filter individual orders over $100
SELECT customer_id, SUM(total) as total_spent
FROM orders
WHERE total > 100
GROUP BY customer_id;

-- HAVING: Filter customers who spent over $1000 total
SELECT customer_id, SUM(total) as total_spent
FROM orders
GROUP BY customer_id
HAVING SUM(total) > 1000;
```

Производительность: WHERE всегда предпочтительнее, когда это возможно — он уменьшает набор данных до дорогостоящей операции GROUP BY.
</details>

<details>
<summary><strong>3. В чём разница между INNER JOIN, LEFT JOIN, RIGHT JOIN и FULL OUTER JOIN?</strong></summary>
<br>

- **INNER JOIN**: Возвращает только строки, имеющие совпадающие значения в **обеих** таблицах. Несовпадающие строки исключаются.
- **LEFT JOIN**: Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадения нет, правые столбцы равны NULL.
- **RIGHT JOIN**: Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадения нет, левые столбцы равны NULL.
- **FULL OUTER JOIN**: Возвращает все строки из обеих таблиц. Где нет совпадения, отсутствующая сторона равна NULL.

На практике LEFT JOIN используется примерно в 90% случаев. RIGHT JOIN всегда можно переписать как LEFT JOIN, поменяв порядок таблиц.
</details>

<details>
<summary><strong>4. В чём разница между UNION и UNION ALL?</strong></summary>
<br>

- **UNION**: Объединяет результаты двух запросов и **удаляет дублирующиеся строки**. Требует внутренней операции сортировки/дедупликации.
- **UNION ALL**: Объединяет результаты **без удаления дубликатов**. Быстрее, поскольку дедупликация не нужна.

Всегда используйте `UNION ALL`, если вам не нужна именно дедупликация. Неявная операция сортировки `UNION` может быть дорогостоящей на больших наборах данных.

Оба требуют одинаковое количество столбцов с совместимыми типами данных в каждом SELECT.
</details>

## Проектирование баз данных

<details>
<summary><strong>5. Объясните нормализацию баз данных (от 1НФ до 3НФ).</strong></summary>
<br>

Нормализация уменьшает избыточность данных и предотвращает аномалии обновления:

- **1НФ** (Первая нормальная форма): Каждый столбец содержит атомарные (неделимые) значения. Нет повторяющихся групп. Каждая строка уникальна (имеет первичный ключ).
- **2НФ**: Соответствует 1НФ + каждый неключевой столбец зависит от **всего** первичного ключа (а не только от части составного ключа). Устраняет частичные зависимости.
- **3НФ**: Соответствует 2НФ + каждый неключевой столбец зависит **напрямую** от первичного ключа, а не от другого неключевого столбца. Устраняет транзитивные зависимости.

Пример нарушения 3НФ: Таблица с `(order_id, customer_id, customer_name)` — `customer_name` зависит от `customer_id`, а не от `order_id`. Решение: Переместить `customer_name` в отдельную таблицу `customers`.
</details>

<details>
<summary><strong>6. Когда вы бы намеренно денормализовали базу данных?</strong></summary>
<br>

Денормализация оправдана, когда:

1. **Производительность чтения критична**: Дашборды отчётности, аналитические запросы, объединяющие множество таблиц. Предварительное вычисление агрегатов или выравнивание иерархий позволяет избежать дорогостоящих соединений во время запроса.
2. **Слои кэширования**: Материализованные представления или сводные таблицы, которые обновляются периодически.
3. **NoSQL/Документные хранилища**: Данные хранятся как полные документы (MongoDB). Встраивание связанных данных полностью исключает соединения.
4. **Event sourcing/CQRS**: Модель записи нормализована, модель чтения денормализована.

Компромисс: более быстрое чтение за счёт более сложной записи (необходимо обновлять несколько мест) и потенциальной несогласованности данных.
</details>

<details>
<summary><strong>7. Что такое свойства ACID?</strong></summary>
<br>

ACID гарантирует надёжные транзакции базы данных:

- **Атомарность**: Транзакция — это «всё или ничего». Если какая-либо часть не удаётся, вся транзакция откатывается. Никаких частичных обновлений.
- **Согласованность**: Транзакция переводит базу данных из одного допустимого состояния в другое. Все ограничения (внешние ключи, проверки, триггеры) удовлетворены.
- **Изоляция**: Параллельные транзакции не мешают друг другу. Каждая транзакция видит согласованный снимок данных.
- **Долговечность**: После фиксации транзакции она переживает сбои системы. Данные записываются в энергонезависимое хранилище (WAL, redo-логи).

ACID — это определяющая характеристика реляционных баз данных (PostgreSQL, MySQL InnoDB). Многие NoSQL-базы данных жертвуют некоторыми свойствами ACID ради масштабируемости (BASE: Basically Available, Soft state, Eventually consistent).
</details>

<details>
<summary><strong>8. Объясните уровни изоляции транзакций.</strong></summary>
<br>

От наименее до наиболее строгого:

1. **Read Uncommitted**: Может читать незафиксированные изменения других транзакций (**грязное чтение**). Почти никогда не используется.
2. **Read Committed** (по умолчанию в PostgreSQL): Читает только зафиксированные данные. Но повторное чтение той же строки может вернуть другие значения, если другая транзакция была зафиксирована между чтениями (**неповторяющееся чтение**).
3. **Repeatable Read** (по умолчанию в MySQL InnoDB): Повторное чтение той же строки всегда возвращает одно и то же значение в пределах транзакции. Но новые строки, вставленные другими транзакциями, могут появиться (**фантомное чтение**).
4. **Serializable**: Полная изоляция. Транзакции выполняются так, как если бы они были последовательными (одна за другой). Предотвращает все аномалии, но имеет наибольшую стоимость производительности (накладные расходы блокировки/MVCC).

Выбирайте в зависимости от приложения: финансовые транзакции требуют Serializable; чтение в веб-приложениях обычно использует Read Committed.
</details>

## Индексирование и производительность

<details>
<summary><strong>9. Что такое индекс базы данных и как он работает?</strong></summary>
<br>

Индекс — это отдельная структура данных (обычно **B-дерево** или **B+ дерево**), которая хранит отсортированную копию определённых столбцов вместе с указателями на полные строки. Он позволяет базе данных находить строки без сканирования всей таблицы (полное сканирование таблицы).

Аналогия: Предметный указатель книги сопоставляет ключевые слова с номерами страниц. Без него вам придётся читать каждую страницу, чтобы найти тему.

Компромиссы:
- **Более быстрое чтение**: SELECT с WHERE, JOIN, ORDER BY по индексированным столбцам.
- **Более медленная запись**: Каждый INSERT, UPDATE, DELETE также должен обновлять индекс.
- **Больше места**: Индекс занимает дисковое пространство, пропорциональное индексированным данным.

Правило: Индексируйте столбцы, которые часто появляются в предложениях WHERE, JOIN ON, ORDER BY и GROUP BY.
</details>

<details>
<summary><strong>10. В чём разница между кластеризованным и некластеризованным индексом?</strong></summary>
<br>

- **Кластеризованный индекс**: Определяет **физический порядок** данных на диске. Таблица может иметь только один кластеризованный индекс (обычно первичный ключ). Листовые узлы B-дерева содержат фактические строки данных.
- **Некластеризованный индекс**: Отдельная структура с указателями на строки данных. Таблица может иметь несколько некластеризованных индексов. Листовые узлы содержат значения индексированных столбцов и ссылку (локатор строки) на фактические данные.

В PostgreSQL нет явного понятия кластеризованного индекса — команда `CLUSTER` физически переупорядочивает данные один раз, но автоматически не поддерживается. InnoDB (MySQL) всегда кластеризует данные по первичному ключу.
</details>

<details>
<summary><strong>11. Как вы оптимизируете медленный запрос?</strong></summary>
<br>

Пошаговый подход:

1. **EXPLAIN ANALYZE**: Прочитайте план запроса. Ищите последовательные сканирования (Seq Scan), завышенные оценки строк и операции сортировки на больших наборах данных.
2. **Добавьте недостающие индексы**: Если столбцы WHERE/JOIN не имеют индексов, создайте их.
3. **Перепишите запрос**: Замените подзапросы на JOIN. Используйте EXISTS вместо IN для больших подмножеств. Избегайте SELECT * — выбирайте только нужные столбцы.
4. **Избегайте функций на индексированных столбцах**: `WHERE YEAR(created_at) = 2026` не может использовать индекс на `created_at`. Перепишите как `WHERE created_at >= '2026-01-01' AND created_at < '2027-01-01'`.
5. **Пагинация**: Используйте пагинацию по ключу (`WHERE id > last_seen_id LIMIT 20`) вместо `OFFSET` (который сканирует и отбрасывает строки).
6. **Статистика**: Выполните `ANALYZE` (PostgreSQL) для обновления статистики таблиц, чтобы планировщик принимал лучшие решения.
</details>

<details>
<summary><strong>12. Что такое покрывающий индекс?</strong></summary>
<br>

Покрывающий индекс содержит все столбцы, необходимые для выполнения запроса, поэтому базе данных не нужно обращаться к фактическим данным таблицы (нет «heap fetch» или «bookmark lookup»). Запрос полностью обслуживается из индекса.

```sql
-- Query
SELECT email, name FROM users WHERE email = 'user@example.com';

-- Covering index (includes all needed columns)
CREATE INDEX idx_users_email_name ON users(email) INCLUDE (name);
```

PostgreSQL использует `INCLUDE` для неключевых столбцов. MySQL использует составные индексы, где дополнительные столбцы добавляются в конец. Покрывающие индексы могут значительно улучшить производительность чтения для определённых шаблонов запросов.
</details>

## Продвинутые концепции

<details>
<summary><strong>13. Что такое Common Table Expression (CTE) и когда бы вы его использовали?</strong></summary>
<br>

CTE — это именованный временный набор результатов, определённый внутри одного запроса с помощью `WITH`:

```sql
WITH high_spenders AS (
    SELECT customer_id, SUM(total) as total_spent
    FROM orders
    GROUP BY customer_id
    HAVING SUM(total) > 10000
)
SELECT c.name, hs.total_spent
FROM customers c
JOIN high_spenders hs ON c.id = hs.customer_id;
```

Используйте CTE для: читаемости (разбиение сложных запросов на логические шаги), рекурсивных запросов (иерархические данные, такие как организационные структуры) и замены сложных подзапросов. Примечание: В PostgreSQL < 12 CTE действуют как барьеры оптимизации (не встраиваются). В PostgreSQL 12+ нерекурсивные CTE могут быть встроены.
</details>

<details>
<summary><strong>14. Что такое оконные функции и чем они отличаются от GROUP BY?</strong></summary>
<br>

Оконные функции вычисляют значение по набору строк, **не сворачивая их в одну строку** (в отличие от GROUP BY).

```sql
-- GROUP BY: One row per department
SELECT department, AVG(salary) FROM employees GROUP BY department;

-- Window function: Every row, with department average added
SELECT name, department, salary,
       AVG(salary) OVER (PARTITION BY department) as dept_avg,
       RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank
FROM employees;
```

Распространённые оконные функции: `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `LAG()`, `LEAD()`, `SUM() OVER()`, `AVG() OVER()`. Незаменимы для аналитики, отчётности и пагинации.
</details>

<details>
<summary><strong>15. Что такое взаимная блокировка (deadlock) и как её предотвратить?</strong></summary>
<br>

Взаимная блокировка возникает, когда две транзакции ждут, пока другая освободит блокировки, создавая циклическую зависимость. Ни одна не может продолжить.

Пример:
- Транзакция A блокирует Строку 1, хочет Строку 2.
- Транзакция B блокирует Строку 2, хочет Строку 1.
- Обе ждут бесконечно.

База данных обнаруживает взаимные блокировки и завершает одну транзакцию («жертву»), откатывая её.

Предотвращение:
1. **Согласованный порядок блокировки**: Всегда блокируйте ресурсы в одном и том же порядке во всех транзакциях.
2. **Короткие транзакции**: Удерживайте блокировки минимально необходимое время.
3. **Таймауты блокировок**: Установите `lock_timeout`, чтобы транзакции быстро завершались с ошибкой, а не ждали бесконечно.
4. **Снижение уровня изоляции**: Более низкие уровни изоляции требуют меньше блокировок.
</details>

## Безопасность

<details>
<summary><strong>16. Что такое SQL-инъекция и как её предотвратить?</strong></summary>
<br>

SQL-инъекция возникает, когда пользовательский ввод напрямую конкатенируется в SQL-запрос, позволяя злоумышленнику изменить логику запроса.

```python
# VULNERABLE
query = f"SELECT * FROM users WHERE username = '{user_input}'"
# If user_input = "' OR 1=1--", returns all users

# SAFE: Parameterized query
cursor.execute("SELECT * FROM users WHERE username = %s", (user_input,))
```

Предотвращение:
1. **Параметризованные запросы** (подготовленные выражения) — защита номер 1. Ввод обрабатывается как данные, а не как SQL.
2. **ORM** (SQLAlchemy, Django ORM) — автоматически генерирует параметризованные запросы.
3. **Валидация ввода** — белый список ожидаемых форматов (числовые ID, шаблоны email).
4. **Принцип минимальных привилегий** — пользователь базы данных должен иметь только SELECT/INSERT/UPDATE на нужных таблицах, никогда DROP или GRANT.
</details>

<details>
<summary><strong>17. Что такое принцип минимальных привилегий в безопасности баз данных?</strong></summary>
<br>

Каждый пользователь базы данных или приложение должен иметь только минимальные разрешения, необходимые для выполнения своей работы.

```sql
-- Application user: Only needs CRUD on specific tables
CREATE USER app_user WITH PASSWORD 'secure_password';
GRANT SELECT, INSERT, UPDATE ON users, orders TO app_user;
-- No DELETE, no DROP, no access to other tables

-- Admin user: Full access but should not be used by the application
CREATE USER admin_user WITH PASSWORD 'admin_password';
GRANT ALL PRIVILEGES ON DATABASE myapp TO admin_user;
```

Никогда не используйте суперпользователя базы данных (postgres, root) для подключений приложения. Если приложение скомпрометировано через SQL-инъекцию, злоумышленник получает только права ограниченного пользователя.
</details>

## Практические сценарии

<details>
<summary><strong>18. Как спроектировать схему для связи «многие ко многим»?</strong></summary>
<br>

Используйте **связующую таблицу** (также называемую промежуточной или ассоциативной таблицей):

```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200)
);

-- Junction table
CREATE TABLE enrollments (
    student_id INT REFERENCES students(id),
    course_id INT REFERENCES courses(id),
    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    grade VARCHAR(2),
    PRIMARY KEY (student_id, course_id)
);
```

Связующая таблица содержит внешние ключи к обеим таблицам, создавая связь «многие ко многим». Она также может содержать атрибуты, специфичные для связи (enrolled_at, grade).
</details>

<details>
<summary><strong>19. Напишите запрос для нахождения второй по величине зарплаты в каждом отделе.</strong></summary>
<br>

```sql
-- Using window function (cleanest approach)
WITH ranked AS (
    SELECT name, department, salary,
           DENSE_RANK() OVER (
               PARTITION BY department
               ORDER BY salary DESC
           ) as rank
    FROM employees
)
SELECT name, department, salary
FROM ranked
WHERE rank = 2;
```

Почему `DENSE_RANK` вместо `ROW_NUMBER`: Если два сотрудника имеют одинаковую наивысшую зарплату, `DENSE_RANK` правильно присваивает ранг 2 следующей зарплате. `ROW_NUMBER` произвольно присвоил бы ранги 1 и 2 сотрудникам с одинаковой зарплатой.
</details>

<details>
<summary><strong>20. Как вы управляете миграциями базы данных в продакшене?</strong></summary>
<br>

1. **Используйте инструмент миграции**: Flyway, Liquibase (Java), Alembic (Python/SQLAlchemy), Django migrations, Prisma Migrate. Никогда не выполняйте сырой DDL в продакшене.
2. **Версионирование миграций**: Каждая миграция — это пронумерованный файл в репозитории. Миграции применяются по порядку и отслеживаются в таблице метаданных.
3. **Обратно совместимые изменения**: Сначала добавьте новые столбцы как nullable. Разверните код приложения, использующий новый столбец. Затем добавьте ограничение NOT NULL при необходимости. Никогда не переименовывайте и не удаляйте столбцы без периода устаревания.
4. **Тестирование миграций**: Запустите на staging-копии продакшен-данных перед применением в продакшене.
5. **План отката**: Каждая миграция должна иметь соответствующий скрипт отката. Тестируйте откаты перед развёртыванием.
6. **Нулевое время простоя**: Используйте техники, такие как паттерны расширения/сужения, ghost-таблицы (gh-ost для MySQL) или онлайн-DDL (неблокирующий ALTER TABLE в PostgreSQL).
</details>
