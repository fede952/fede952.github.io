---
title: "Git Disaster Recovery: Отмена Ошибок и Исправление Истории"
description: "Аварийный набор для разработчиков. Научитесь отменять коммиты, разрешать конфликты слияния, восстанавливать удалённые ветки и освойте git rebase vs merge."
date: 2026-02-13
tags: ["git", "cheatsheet", "devops", "version-control"]
keywords: ["git отменить коммит", "git reset hard vs soft", "восстановить удалённую ветку", "git rebase учебник", "исправить конфликт слияния", "git cherry-pick"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Git Disaster Recovery: Отмена Ошибок и Исправление Истории",
    "description": "Аварийный набор для разработчиков. Научитесь отменять коммиты, разрешать конфликты слияния, восстанавливать удалённые ветки и освойте git rebase vs merge.",
    "proficiencyLevel": "Intermediate",
    "inLanguage": "ru"
  }
---

## Отмена Изменений

Три столпа «Я всё испортил»: reset, revert и restore. У каждого своя область применения и уровень опасности.

### git restore — Отмена Неиндексированных Изменений

```bash
# Отменить изменения в одном файле (только рабочая директория)
git restore file.txt

# Отменить ВСЕ неиндексированные изменения
git restore .

# Убрать файл из индекса (сохранить изменения в рабочей директории)
git restore --staged file.txt

# Восстановить файл до версии конкретного коммита
git restore --source=abc1234 file.txt
```

### git reset — Переместить HEAD Назад

```bash
# Мягкий сброс: отменить коммит, оставить изменения в индексе
git reset --soft HEAD~1

# Смешанный сброс (по умолчанию): отменить коммит, убрать из индекса, сохранить файлы
git reset HEAD~1

# Жёсткий сброс: отменить коммит, УДАЛИТЬ все изменения безвозвратно
git reset --hard HEAD~1

# Сбросить до конкретного коммита
git reset --hard abc1234
```

> **--soft** оставляет всё в индексе. **--mixed** убирает из индекса, но сохраняет файлы. **--hard** уничтожает всё. Если сомневаетесь — используйте `--soft`.

### git revert — Безопасная Отмена Коммита (Публичная История)

```bash
# Создать новый коммит, который отменяет конкретный коммит
git revert abc1234

# Отменить без автоматического коммита (только индексировать изменения)
git revert --no-commit abc1234

# Отменить merge-коммит (сохранить родителя #1)
git revert -m 1 <merge-commit-hash>
```

> Используйте `revert` вместо `reset` на общих ветках — он не переписывает историю.

---

## Переписывание Истории

Для случаев, когда ваши сообщения коммитов вызывают стыд или история ветки — полный хаос.

### git commit --amend

```bash
# Изменить сообщение последнего коммита
git commit --amend -m "better message"

# Добавить забытые файлы к последнему коммиту
git add forgotten-file.txt
git commit --amend --no-edit
```

### git rebase -i (Интерактивный Rebase)

```bash
# Переписать последние 3 коммита
git rebase -i HEAD~3
```

В редакторе вы можете:

| Команда  | Эффект                              |
|----------|-------------------------------------|
| `pick`   | Оставить коммит как есть            |
| `reword` | Изменить сообщение коммита          |
| `edit`   | Остановиться для редактирования     |
| `squash` | Объединить с предыдущим коммитом    |
| `fixup`  | Как squash, но отбросить сообщение  |
| `drop`   | Полностью удалить коммит            |

```bash
# Перебазировать текущую ветку на main (линейная история)
git rebase main

# Продолжить после разрешения конфликтов
git rebase --continue

# Прервать неудачный rebase
git rebase --abort
```

> **Rebase vs Merge:** Rebase создаёт линейную историю (чистые логи). Merge сохраняет топологию веток (безопаснее для общих веток). Никогда не выполняйте rebase коммитов, которые другие уже получили.

---

## Восстановление

Когда всё горит, эти команды — ваш огнетушитель.

### git reflog — Спасательный Круг

Reflog записывает каждое перемещение HEAD. Даже после жёсткого сброса ваши коммиты всё ещё на месте.

```bash
# Просмотреть reflog (все недавние позиции HEAD)
git reflog

# Пример вывода:
# abc1234 HEAD@{0}: reset: moving to HEAD~3
# def5678 HEAD@{1}: commit: add feature X
# 9ab0123 HEAD@{2}: commit: fix login bug

# Восстановить, сбросив до записи в reflog
git reset --hard HEAD@{1}

# Или перенести потерянный коммит через cherry-pick
git cherry-pick def5678
```

### git fsck — Поиск Потерянных Объектов

```bash
# Найти недостижимые коммиты и блобы
git fsck --unreachable

# Найти именно потерянные коммиты
git fsck --lost-found
# Результаты сохраняются в .git/lost-found/
```

### Восстановление Удалённой Ветки

```bash
# Шаг 1: найти последний коммит удалённой ветки
git reflog | grep "branch-name"
# Или искать по сообщению коммита
git reflog | grep "feature I was working on"

# Шаг 2: пересоздать ветку на этом коммите
git branch recovered-branch abc1234

# Альтернатива: найти и восстановить одной командой
git checkout -b recovered-branch HEAD@{5}
```

---

## Типичные Аварийные Сценарии

### «Я закоммитил не в ту ветку»

```bash
# Шаг 1: Запишите хеш коммита
git log --oneline -1
# abc1234 accidental commit

# Шаг 2: Отмените коммит на неправильной ветке (сохранить изменения)
git reset --soft HEAD~1

# Шаг 3: Спрятать, переключиться и применить
git stash
git checkout correct-branch
git stash pop
git add . && git commit -m "feature in the right place"
```

### «Мне нужно прекратить отслеживание файла, но сохранить его локально»

```bash
# Убрать из отслеживания git, но оставить файл на диске
git rm --cached secret-config.env

# Добавить в .gitignore для предотвращения отслеживания в будущем
echo "secret-config.env" >> .gitignore
git add .gitignore
git commit -m "stop tracking secret-config.env"
```

### «Мне нужно отменить push»

```bash
# Безопасный способ: отменить коммит (создаёт новый коммит)
git revert abc1234
git push

# Ядерный вариант: принудительный push (ОПАСНО на общих ветках)
git reset --hard HEAD~1
git push --force-with-lease
```

### «У меня конфликты при слиянии повсюду»

```bash
# Посмотреть, в каких файлах конфликты
git status

# В каждом конфликтном файле ищите маркеры конфликтов:
# <<<<<<< HEAD
# ваши изменения
# =======
# их изменения
# >>>>>>> branch-name

# После разрешения всех конфликтов:
git add .
git commit

# Или полностью отменить слияние
git merge --abort
```

### git cherry-pick — Забрать Конкретные Коммиты

```bash
# Применить один коммит из другой ветки
git cherry-pick abc1234

# Применить несколько коммитов
git cherry-pick abc1234 def5678

# Cherry-pick без коммита (только индексировать)
git cherry-pick --no-commit abc1234
```

---

## Краткая Справочная Таблица

| Ситуация | Команда |
|----------|---------|
| Отменить последний коммит (сохранить изменения) | `git reset --soft HEAD~1` |
| Отменить последний коммит (удалить изменения) | `git reset --hard HEAD~1` |
| Отменить запушенный коммит | `git revert <hash>` |
| Отменить изменения в файле | `git restore <file>` |
| Убрать файл из индекса | `git restore --staged <file>` |
| Восстановить удалённую ветку | `git reflog` + `git branch name <hash>` |
| Исправить сообщение последнего коммита | `git commit --amend -m "new msg"` |
| Объединить последние N коммитов | `git rebase -i HEAD~N` |
| Перенести коммит в правильную ветку | `git reset --soft HEAD~1` + stash + switch |
| Прекратить отслеживание файла | `git rm --cached <file>` |
