---
title: "Протокол Git: Основная Справка по Командам"
description: "Тактическая шпаргалка по Git, охватывающая экстренные исправления, подпись GPG, операции с ветками и продвинутые рабочие процессы. Команды, которые должен знать наизусть каждый разработчик и хакер."
date: 2026-02-10
tags: ["git", "cheatsheet", "version-control", "developer-tools"]
keywords: ["git команды шпаргалка", "git отменить коммит", "git подпись gpg", "git команды веток", "руководство git reset", "руководство git rebase", "продвинутые git команды", "git для хакеров"]
draft: false
schema_json: >
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "Протокол Git: Основная Справка по Командам",
    "description": "Полная шпаргалка по командам Git, охватывающая экстренные исправления, подпись GPG, операции с ветками и продвинутые рабочие процессы.",
    "proficiencyLevel": "Intermediate",
    "inLanguage": "ru"
  }
---

## $ System_Init

Каждая операция оставляет след. Каждый коммит — это контрольная точка. Git — это не просто система контроля версий, это криминалистическая основа каждого программного проекта. Это полевое руководство содержит команды, которые вы будете использовать ежедневно, и те, которые спасут вас, когда всё сломается.

Команды организованы по типу задачи. Выполняйте с точностью.

---

## $ Emergency_Fixes

Когда развертывание идёт не так, и временную линию нужно переписать.

### Отменить последний коммит (сохранить изменения в staging)

```bash
# Отменяет последний коммит, но сохраняет ваши изменения в области staging
git reset --soft HEAD~1
```

### Отменить последний коммит (убрать из staging)

```bash
# Отменяет последний коммит и перемещает изменения обратно в рабочий каталог
git reset --mixed HEAD~1
```

### Ядерный сброс (уничтожить все локальные изменения)

```bash
# ВНИМАНИЕ: Это навсегда уничтожает всю незакоммиченную работу
git reset --hard HEAD~1
```

### Изменить сообщение последнего коммита

```bash
# Исправьте опечатку в вашем последнем сообщении коммита без создания нового коммита
git commit --amend -m "исправленное сообщение коммита"
```

### Восстановить удалённую ветку

```bash
# Найдите потерянный хеш коммита в reflog
git reflog

# Пересоздайте ветку из восстановленного хеша
git checkout -b recovered-branch abc1234
```

### Отменить коммит без переписывания истории

```bash
# Создаёт новый коммит, который отменяет конкретный коммит (безопасно для общих веток)
git revert <commit-hash>
```

---

## $ Stealth_Mode

Криптографическая подпись и проверка подлинности. Докажите, что ваши коммиты аутентичны.

### Настроить подпись GPG

```bash
# Список ваших доступных ключей GPG
gpg --list-secret-keys --keyid-format=long

# Скажите Git, какой ключ использовать
git config --global user.signingkey YOUR_KEY_ID

# Включите автоматическую подпись для всех коммитов
git config --global commit.gpgsign true
```

### Подписать один коммит

```bash
# Вручную подпишите конкретный коммит
git commit -S -m "signed: verified deployment"
```

### Проверить подписи коммитов

```bash
# Проверьте подпись последнего коммита
git log --show-signature -1

# Проверьте подписи во всём логе
git log --pretty="format:%h %G? %aN %s"
```

### Подписать теги для релизов

```bash
# Создайте подписанный тег релиза
git tag -s v1.0.0 -m "Release v1.0.0 - signed"

# Проверьте подписанный тег
git tag -v v1.0.0
```

---

## $ Branch_Operations

Тактическое управление ветками для параллельной разработки.

### Создать и переключиться на новую ветку

```bash
# Создайте ветку feature и переключитесь на неё одной командой
git checkout -b feature/new-module
```

### Список всех веток (локальных и удалённых)

```bash
# Показать все ветки, включая ветки отслеживания удалённых репозиториев
git branch -a
```

### Безопасно удалить ветку

```bash
# Удалить локальную ветку (только если полностью слита)
git branch -d feature/old-module

# Принудительно удалить локальную ветку (даже если не слита)
git branch -D feature/abandoned-experiment
```

### Удалить удалённую ветку

```bash
# Удалить ветку из удалённого репозитория
git push origin --delete feature/old-module
```

### Rebase на main (линейная история)

```bash
# Переприменить коммиты вашей ветки поверх последнего main
git checkout feature/my-work
git rebase main
```

### Интерактивный rebase (squash, переупорядочить, редактировать)

```bash
# Перепишите последние 3 коммита интерактивно
git rebase -i HEAD~3
```

---

## $ Reconnaissance

Проверьте состояние репозитория перед принятием решений.

### Просмотр компактного лога с графиком

```bash
# Однострочный лог с графической визуализацией веток
git log --oneline --graph --all --decorate
```

### Показать изменения в области staging

```bash
# Сравните изменения в staging с последним коммитом
git diff --cached
```

### Blame для файла (найти, кто изменил каждую строку)

```bash
# Показать автора и коммит для каждой строки в файле
git blame path/to/file.py
```

### Поиск в сообщениях коммитов

```bash
# Найдите коммиты, содержащие конкретное ключевое слово в сообщении
git log --grep="bugfix" --oneline
```

### Найти, какой коммит внёс баг

```bash
# Бинарный поиск по коммитам для нахождения изменения, сломавшего код
git bisect start
git bisect bad          # Текущий коммит сломан
git bisect good abc1234 # Этот старый коммит работал
# Git будет делать checkout коммитов для вашего тестирования
```

---

## $ Stash_Operations

Временно отложите работу без коммита.

### Сохранить текущие изменения в stash

```bash
# Сохраните незакоммиченные изменения во временный стек
git stash push -m "work in progress: auth module"
```

### Список всех stash'ей

```bash
# Просмотр всех сохранённых записей в stash
git stash list
```

### Применить и удалить stash

```bash
# Восстановите самый последний stash и удалите его из стека
git stash pop

# Восстановите конкретный stash по индексу
git stash apply stash@{2}
```

### Создать ветку из stash

```bash
# Превратите stash в настоящую ветку feature
git stash branch feature/from-stash stash@{0}
```

---

## $ Advanced_Protocols

Мощные команды для сложных сценариев.

### Cherry-pick коммита из другой ветки

```bash
# Примените конкретный коммит из одной ветки к вашей текущей ветке
git cherry-pick <commit-hash>
```

### Очистить неотслеживаемые файлы

```bash
# Предварительный просмотр того, что будет удалено
git clean -n

# Удалить неотслеживаемые файлы и каталоги
git clean -fd
```

### Создать файл patch

```bash
# Экспортируйте последний коммит как портативный файл patch
git format-patch -1 HEAD

# Применить файл patch
git am < patch-file.patch
```

### Поверхностное клонирование (экономия трафика)

```bash
# Клонируйте только последний коммит (без полной истории)
git clone --depth 1 https://github.com/user/repo.git
```
